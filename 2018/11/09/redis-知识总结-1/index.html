<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> redis 知识总结(1) · Yab Zhang's Blog</title><meta name="description" content="redis 知识总结(1) - Yab Zhang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://yabzhang.github.io/atom.xml" title="Yab Zhang's Blog"><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Yab Zhang's Blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/yabzhang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">redis 知识总结(1)</h1><div class="post-info">Nov 9, 2018</div><div class="post-content"><p><code>redis</code>是最常用的内存数据库，性能强悍，且支持丰富的数据类型。<br>一般主要用于高频访问数据的缓存，是现代构建高性能web系统的重要组件之一。</p>
<p>本文主要是总结和记录redis基本的命令和功能。</p>
<a id="more"></a>

<h3 id="redis-命令"><a href="#redis-命令" class="headerlink" title="redis 命令"></a>redis 命令</h3><p><code>redis</code>支持丰富的数据类型，本人使用最多的是: 字符串(string)，散列表(hash)，列表(list), 集合(set)，有序集合(sorted set)。<br>此外，<code>redis</code>还支持bitmap, hyperloglogs, 和地理数据(geospatial)等高级数据类型。<br>除了数据类型，<code>redis</code>还提供了通用功能的命令，维护和管理的命令。</p>
<p>下面针对各种命令作下基本的介绍：</p>
<ul>
<li>键<code>keys</code></li>
</ul>
<p>redis中保存的数据都是以键值对的形式保存的。<br>本类命令主要包含redis较通用的功能，如：删除(<code>DEL</code>)，判断存在性(<code>EXISTS</code>), 标记过期(<code>EXPIRE</code>), 查询TTL(<code>TTL</code>), 迁移(<code>MOVE</code>)，重命名(<code>RENAME</code>)，类型检测(<code>TYPE</code>)等</p>
<p>更多参见文档:  <a href="http://www.redis.cn/commands/del.html" target="_blank" rel="noopener">http://www.redis.cn/commands/del.html</a></p>
<ul>
<li>字符串(<code>string</code>)</li>
</ul>
<p>字符串类型的值可以是字符或者数据。<br>redis支持直接对字符串类型修改以及追加: <code>SET</code>, <code>APPEND</code>; 若值为数字类型还可以进行增减操作(用于计数器): <code>INCR</code>, <code>INCRBY</code>, <code>DECR</code>, <code>DECRBY</code>等；<br>对于字符串类型的值还支持位运算和按位索引, 具体使用参见文档: <a href="http://www.redis.cn/commands/append.html" target="_blank" rel="noopener">http://www.redis.cn/commands/append.html</a></p>
<p>使用redis的字符串类型，可以很方便地实现一个分布式锁(仅用于演示，用于生产环境仍有风险！)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lock_key, timeout=<span class="number">3</span>)</span>:</span></span><br><span class="line">        self._lock_key = lock_key</span><br><span class="line">        self._timeout = timeout</span><br><span class="line">        self._get_locked = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        _lock = redis.setnx(self._lock_key, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> _lock:</span><br><span class="line">            self._get_locked = <span class="literal">True</span></span><br><span class="line">            redis.expire(self._lock_key, self._timeout)  <span class="comment"># 注意：此处失败的话，锁无法移除；</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, *exc_info)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._get_locked:</span><br><span class="line">            redis.delete(self._lock_key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lock_key = <span class="string">"get_user_lock?user_id=%s"</span> % <span class="number">101</span></span><br><span class="line"><span class="keyword">with</span> Lock(lock_key) <span class="keyword">as</span> lock:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> lock:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>  <span class="comment"># get lock failed!</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<ul>
<li>列表(<code>List</code>)和集合(<code>Set</code>)</li>
</ul>
<p>列表和集合都是常规的数据结构，redis也提供了丰富的命令支持多种操作；</p>
<p>列表命令: <a href="http://www.redis.cn/commands.html#list" target="_blank" rel="noopener">http://www.redis.cn/commands.html#list</a><br>列表提供了<code>安全队列</code>的命令，可以从一个列表(队列)取出元素返回并且加入另一个列表,而且这一系列操作是原子的；</p>
<p>集合类型支持常规的集合操作(增加元素，移除元素，取交、并、差集), 还支持对两个集合操作后结果保存在新的集合中(无需返回结果)；<br>集合操作: <a href="http://www.redis.cn/commands.html#set" target="_blank" rel="noopener">http://www.redis.cn/commands.html#set</a></p>
<ul>
<li>有序集合(<code>Sorted Set</code>)</li>
</ul>
<p>有序集合是redis特别提供的数据类型，有序集合除了想一般的集合一样可以保证每一个成员(<code>member</code>)是唯一的，还允许未成员指定一个分数(<code>score</code>);</p>
<p>通过对成员的分数做排序，这样就可以按照分值对有序的成员做批量操作；如批量获取，批量移除，取分数最大或者分数最小等等；<br>此外，有序集合还可以兼容一般的集合运算；</p>
<p>有序集合的概念非常强大；本人平时使用较多的就是<code>zrange</code>和<code>zrangebyscore</code>按照成员排序位置索引或者分数来获取顺序元素；这样可以方便地通过redis来维护有序列表数据，从而避免了依靠关系数据库做查询和排序；</p>
<p>具体的文档: <a href="http://www.redis.cn/commands/zadd.html" target="_blank" rel="noopener">http://www.redis.cn/commands/zadd.html</a></p>
<ul>
<li>哈希表(<code>hash</code>)</li>
</ul>
<p>redis的哈希表就像一组<code>keys</code>类型的集合，对于一组关联的数据使用哈希表可以更加方便地去管理；<br><a href="http://www.redis.cn/commands/hexists.html" target="_blank" rel="noopener">http://www.redis.cn/commands/hexists.html</a></p>
<p>除了以上最常用的数据结构外，redis还支持地理位置(<code>geospatial</code>)和hyperloglogs，发布订阅模式，以及最新的流（<code>stream</code>);</p>
<p>地理位置类型是支持对经纬度坐标点数据的相关索引查询，如按照半径和距离等；<br>而hyperloglogs则是概率算法的计数器，常用于大数据统计，结果有误差；主要特点是占用资源极少；<br>redis支持类似于消息队列的发布和订阅模式，但是redis的发布订阅是<code>fire-and-forget</code>——只推送一次且不保存状态, 不太适合用于消息处理要求较高的场景；</p>
<p>redis 5.0中新增加了流类型(<code>stream</code>), 类似于<code>kafka</code>的任务流模式，支持不停地把消息追加到流中；所有的对流的读取可以依靠消息的索引便宜来获取消息；<br>鉴于流模式是redis新增加的一种类型，且功能强大，后续可以跟进相关的实践应用；</p>
<h3 id="redis-事务"><a href="#redis-事务" class="headerlink" title="redis 事务"></a>redis 事务</h3><p>redis 的事务是依靠一组命令来实现的: <code>MULTI</code>, <code>EXEC</code>, <code>DISCARD</code>, <code>WATCH</code>以及<code>UNWATCH</code></p>
<p>一个事务中可以执行多条命令，并且事务会确保所有的命令被顺序地执行，全部成功或全部失败。<br>redis中由<code>MULTI</code>开启一个事务，添加待执行的命令(此时没有执行),执行<code>EXEC</code>后，事务中的全部命令开始一起执行，全部成功或全部失败;<br><code>DISCARD</code>用于清空已开启的事务队列，放弃本次事务的执行；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; MULTI  # 开启一个事物</span><br><span class="line">OK</span><br><span class="line">&gt; INCR foo</span><br><span class="line">QUEUED</span><br><span class="line">&gt; INCR bar</span><br><span class="line">QUEUED</span><br><span class="line">&gt;EXEC  # 执行事务，并一起返回所有结果</span><br><span class="line">1) (integer) 1</span><br><span class="line">2) (integer) 2</span><br></pre></td></tr></table></figure>
<p>redis事务中添加的命令，只有返回<code>QUEUED</code>时才算成功加入事务; 最新的客户端会在有命令添加报错时放弃事务的执行；<br>而事务中的所有命令都会顺序执行，就算中间又失败，后续命令仍然继续执行；</p>
<p>redis事务不支持回滚；</p>
<p><code>WATCH</code>可以为事务加上乐观锁, 只有被<code>WATCH</code>执行监听后和<code>EXEC</code>执行前健值没有被改变过，事务才会成功执行；否则事务会取消执行；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; SET mykey 1</span><br><span class="line">OK</span><br><span class="line">&gt; WATCH mykey</span><br><span class="line">OK</span><br><span class="line">&gt; INCRBY mykey 5  # watch mykey后，在事务执行前做了改动</span><br><span class="line">6</span><br><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; INCR mykey</span><br><span class="line">QUEUED</span><br><span class="line">&gt; EXEC  # 事务执行失败</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p>此外，redis支持命令流水线(<code>PIPELINE</code>)。但不同于事务，流水线并不能保证全部命令的原子性和一致性；<br>事务中的每个命令都会发往服务器保存，在最后执行完毕后一起返回结果；<br>流水线是把所有的命令缓存在客户端，集中一起发送到服务端去执行，再最后一起返回；<br>事务是可以被包含在流水线中；</p>
<h3 id="redis-持久化"><a href="#redis-持久化" class="headerlink" title="redis 持久化"></a>redis 持久化</h3><p>redis提供了不同级别的的数据持久化，主要是: <code>RDB</code>和<code>AOF</code>;</p>
<ul>
<li>RDB</li>
</ul>
<p>RDB 是在指定的时间点对数据做快照备份，默认已<code>dump.rdb</code>文件保存；<br>因为rdb文件保存的是数据快照，所以其内容比较紧凑，可以很方便地进行远程备份保存和数据回复；<br>但是数据只能回复到快照备份的时间点，这就意味着会有备份后的数据丢失。</p>
<p>RDB在只做数据快照时会fork出一个子进程来完成；<br>而且rdb在回复大数据集方面更有优势；</p>
<ul>
<li>AOF</li>
</ul>
<p>AOF持久化方式会记录每次对服务器写操作，当服务重启时会重新执行这些写操作记录来回复数据；<br>redis以追加的方式把每个写命令加到记录的文件末尾，并且会在后台触发重写以压缩和减小文件的大小；<br>相比于RDB来说，AOF可以保存更完整的数据；redis重启后也会优先载入AOF记录文件来恢复数据；</p>
<p>AOF支持不同的<code>fsync</code>策略来记录指令: 无fsync, 每秒fsync, 每次fsync；<br>一般来说每秒钟fsync一次对性能影响较小，发生事故时也只会丢一小部分数据（具体丢多少要根据故障类型和数据同步到磁盘的侧率而定）；</p>
<p>对于记录损坏的AOF文件可以用<code>redis-check-aof</code>来进行修复；<br>AOF的记录文件体积一般要大于RDB的快照文件，而开启AOF会对性能有一定的影响，回复数据时也会慢一些；但是AOF可以保留更完整的数据；</p>
<p>持久化相关的文档: <a href="http://www.redis.cn/topics/persistence.html" target="_blank" rel="noopener">http://www.redis.cn/topics/persistence.html</a></p>
<p>redis数据持久化的讨论: (client)write =&gt; (db)user space memory =&gt; kernel buffer =&gt; disk controller =&gt; physical media<br><a href="http://oldblog.antirez.com/post/redis-persistence-demystified.html" target="_blank" rel="noopener">http://oldblog.antirez.com/post/redis-persistence-demystified.html</a></p>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>redis best practice: <a href="https://redislabs.com/community/redis-best-practices/" target="_blank" rel="noopener">https://redislabs.com/community/redis-best-practices/</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/11/10/redis-%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-2/" class="prev">PREV</a><a href="/2018/11/07/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-%E2%80%94%E2%80%94-ab/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2020 <a href="https://yabzhang.github.io">Yab Zhang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-103008856-1",'auto');ga('send','pageview');</script></body></html>