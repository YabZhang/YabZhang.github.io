<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yab Zhang&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yabzhang.github.io/"/>
  <updated>2018-08-05T16:46:21.742Z</updated>
  <id>https://yabzhang.github.io/</id>
  
  <author>
    <name>Yab Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mac系统中vim-taglist的配置</title>
    <link href="https://yabzhang.github.io/2018/08/06/mac%E7%B3%BB%E7%BB%9F%E4%B8%ADvim-taglist%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>https://yabzhang.github.io/2018/08/06/mac系统中vim-taglist的配置/</id>
    <published>2018-08-05T16:20:37.000Z</published>
    <updated>2018-08-05T16:46:21.742Z</updated>
    
    <content type="html"><![CDATA[<p><code>taglist</code>, <code>nerdtree</code>, 语法检查等是 <code>vim</code> 最常用的插件。今天在mac系统下配置的 <code>taglist.vim</code> 插件的时候遇到一点坑，特此记录备忘。<br><a id="more"></a></p>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>按照 <a href="http://vim-taglist.sourceforge.net/installation.html" target="_blank" rel="noopener"><code>taglist 官网</code></a> 的描述下载和安装插件后，插件并没有生效。<br><code>which ctags</code> 命令，确认了依赖的 <code>ctags</code> 已经安装。没有头绪。</p>
<p>google 了一下，原来 <code>mac osx</code> 系统自带的 <code>ctags</code> 并不是 <code>taglist</code> 插件依赖的那个。<br>问题确认了，那么安装依赖的软件就好了。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li><p>重装<code>ctags</code></p>
<p> 这里可以去下载源码编译；更简单的方法当然是 <code>brew install ctags</code>;</p>
<p> 我这一步可以看到安装的路径：<code>/usr/local/Cellar/ctags/5.8_1/bin/ctags</code></p>
</li>
<li><p>调整命令</p>
<p> 更新<code>taglist.vim</code>插件的配置，采用新安装的ctags命令来运行插件;<br> 在<code>.vimrc</code>（或位于其他地方的配置文件）中添加：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let g:Tlist_Ctags_Cmd=&apos;$ctags_executable&apos;</span><br><span class="line"></span><br><span class="line"># 比如，我的 `brew install ctags` 安装在 /usr/local/Cellar/ctags/5.8_1/bin/ctags</span><br><span class="line"></span><br><span class="line">let g:Tlist_Ctags_Cmd=&apos;/usr/local/Cellar/ctags/5.8_1/bin/ctags&apos;</span><br></pre></td></tr></table></figure>
<p> 之后在 <code>vim</code> 中尝试下 <code>:TlistToggle</code>，发现函数目录就出来了。</p>
<p> 最后就是添加快捷键(这里配置为<code>F2</code>)：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">noremap &lt;F2&gt; :TlistToggle&lt;CR&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;taglist&lt;/code&gt;, &lt;code&gt;nerdtree&lt;/code&gt;, 语法检查等是 &lt;code&gt;vim&lt;/code&gt; 最常用的插件。今天在mac系统下配置的 &lt;code&gt;taglist.vim&lt;/code&gt; 插件的时候遇到一点坑，特此记录备忘。&lt;br&gt;
    
    </summary>
    
    
      <category term="-- mac -- vim -- taglist" scheme="https://yabzhang.github.io/tags/mac-vim-taglist/"/>
    
  </entry>
  
  <entry>
    <title>pidfile的用途</title>
    <link href="https://yabzhang.github.io/2018/06/17/pidfile%E7%9A%84%E7%94%A8%E9%80%94/"/>
    <id>https://yabzhang.github.io/2018/06/17/pidfile的用途/</id>
    <published>2018-06-17T06:54:29.000Z</published>
    <updated>2018-08-02T17:38:33.846Z</updated>
    
    <content type="html"><![CDATA[<p>在<code>linux</code>系统中经常可以看到很多<code>pid</code>文件，如: <code>/var/run</code>目录下。<br>了解了下这类文件用途，特此记录。</p>
<a id="more"></a>
<h3 id="pidfile"><a href="#pidfile" class="headerlink" title="pidfile"></a>pidfile</h3><p><code>linux</code>下的很多程序会在运行时创建<code>.pid</code>后缀的文件，文件的内容只有一行，程序进程号。<br><code>pidfile</code>一般用于检测某程序是否已经运行，和获取某运行中程序的进程号<code>pid</code>。</p>
<p>检测的逻辑大致是，在程序执行时尝试获取对应pid文件互斥访问权限；<br>若获取成功，则程序继续执行并写入进程号；若获取失败，则退出执行；<br>在程序执行完毕后需要对<code>pidfile</code>进行  清理工作;</p>
<p>看到有些例子中，互斥访问的设计可能会埋坑，比如使用文件是否存在来判断并不准确;<br>Ｃ语言中的 <a href="https://linux.die.net/man/3/pidfile" target="_blank" rel="noopener">pidfile</a> 使用互斥锁的方式来保证<code>pidfile</code>的互斥访问, 会是更好的方案。</p>
<p>尽管如此，<code>pidfile</code>还是有不少问题。<br>就像<code>Supervisor</code>的文档中说的,</p>
<blockquote><p>Pidfiles often lie.</p>
<footer><strong>Supervisor</strong><cite><a href="http://supervisord.org/introduction.html" target="_blank" rel="noopener">supervisord.org/introduction.html</a></cite></footer></blockquote>
<h3 id="pidfile的问题"><a href="#pidfile的问题" class="headerlink" title="pidfile的问题"></a>pidfile的问题</h3><p>有关<code>pidfile</code>的问题，搬运个不错的回答。<a href="https://superuser.com/questions/589698/monitoring-a-process" target="_blank" rel="noopener">monitoring-a-process</a></p>
<ul>
<li><code>pid</code>的数量是有限的，系统复用会用进程号</li>
</ul>
<p>所以有时候<code>pidfile</code>中进程号对应进程运行得可能是其他的程序。<br>由进程号获取的程序状态就不太可信了。冗余的操作是再确定程序启动时间。<br>但事情看起来变得麻烦了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 获取当前系统最大的pid</span><br><span class="line">$ cat /proc/sys/kernel/pid_max</span><br></pre></td></tr></table></figure>
<p>32位系统上限为<code>32768</code>, 64位系统上限为<code>2^22</code>，大约四百多万。<br>更详细的回答参考这篇文章 <a href="https://unix.stackexchange.com/questions/16883/what-is-the-maximum-value-of-the-process-id" target="_blank" rel="noopener">what-is-the-maximum-value-of-the-process-id</a></p>
<ul>
<li>可能的<code>pidfile</code>清理问题</li>
</ul>
<p>通常配置了自启动的脚本，其<code>pidfile</code>并不是脚本创建的。<br>而是自启动服务提供者代为创建，比如: <code>rc</code>, <code>systemd</code>等。<br>这样可能发生<code>pidfile</code>文件的管理和清理等问题。</p>
<h3 id="更好的服务进程管理方式"><a href="#更好的服务进程管理方式" class="headerlink" title="更好的服务进程管理方式"></a>更好的服务进程管理方式</h3><p>自己的轻量级服务或者脚本推荐使用<code>Supervisor</code>。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>打印上一条命令的进程号</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 打印上一条命令的进程号</span><br><span class="line">echo &amp;!</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> e.g</span><br><span class="line">echo '123' &amp; echo &amp;!</span><br><span class="line">which python &amp; echo &amp;!</span><br></pre></td></tr></table></figure>
<ul>
<li>杀死指定程序</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 杀死nginx进程</span><br><span class="line">kill -HUP `cat /path/to/nginx.pid`</span><br></pre></td></tr></table></figure>
<blockquote><p>不要killall，因为一般程序可能会起多个进程，但是只有主进程会接受信号。子进程接受这些信号可能因为没有处理而出错</p>
<footer><strong>叔度,一楼评论</strong><cite><a href="https://www.zhihu.com/question/20289583" target="_blank" rel="noopener">www.zhihu.com/question/20289583</a></cite></footer></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;code&gt;linux&lt;/code&gt;系统中经常可以看到很多&lt;code&gt;pid&lt;/code&gt;文件，如: &lt;code&gt;/var/run&lt;/code&gt;目录下。&lt;br&gt;了解了下这类文件用途，特此记录。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ssh免密设置</title>
    <link href="https://yabzhang.github.io/2018/06/16/%E5%BF%AB%E6%8D%B7ssh%E5%85%8D%E5%AF%86%E8%AE%BE%E7%BD%AE/"/>
    <id>https://yabzhang.github.io/2018/06/16/快捷ssh免密设置/</id>
    <published>2018-06-16T15:05:47.000Z</published>
    <updated>2018-08-02T17:38:33.847Z</updated>
    
    <content type="html"><![CDATA[<p>常用的 <code>ssh</code> 或者 <code>scp</code> 命令一般都会选择配置免密码登录，不然每次输入密码会挺痛苦的。<br>但现在有了更方便的操作方法，一个方便的命令 <strong><code>ssh-copy-id</code></strong>，特此记录备忘。</p>
<a id="more"></a>
<p>常规是手动将公钥拷贝到目标主机 <code>~/.ssh/authorized_keys</code>，再对文件目录访问权限进行配置。<br>相比之下，一句<code>ssh-copy-id</code>命令可以大大节约配置的时间。下面来看下具体操作流程。</p>
<h3 id="设置-ssh-免密登录"><a href="#设置-ssh-免密登录" class="headerlink" title="设置 ssh 免密登录"></a>设置 ssh 免密登录</h3><h4 id="1-在本地生成-ssh-公钥和秘钥"><a href="#1-在本地生成-ssh-公钥和秘钥" class="headerlink" title="1. 在本地生成　ssh　公钥和秘钥"></a>1. 在本地生成　ssh　公钥和秘钥</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#　生成公钥密钥对</span><br><span class="line"></span><br><span class="line">ssh-keygen -b 4096 -t rsa</span><br></pre></td></tr></table></figure>
<p>这里指定的是 <code>rsa</code>　加密的类型，长度为4096位。<br>生成的秘钥就存储在 <code>~/.ssh/id_rsa</code> 中，公钥在 <code>~/.ssh/id_rsa.pub</code> 中。</p>
<h4 id="2-将公钥上传到目标主机"><a href="#2-将公钥上传到目标主机" class="headerlink" title="2. 将公钥上传到目标主机"></a>2. 将公钥上传到目标主机</h4><p>这一步就可以使用 <code>ssh-copy-id</code> 来完成, 而这个命令包含在<strong><code>openssh-client</code></strong>软件包中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 先安装`openssh-client`软件包</span><br><span class="line">sudo apt-get install openssh-client</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 确认ssh-copy-id可用</span><br><span class="line">which ssh-copy-id</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 添加秘钥到目标主机</span><br><span class="line">ssh-copy-id username@remote-server</span><br></pre></td></tr></table></figure>
<p>其中 username 为目标主机的用户名, remote-server 为目标主机的host或者ip；<br>本次登录需要输入密码，登录后<code>ssh-copy-id</code>命令就自动完成了其他的免密设置。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://www.linuxdashen.com/ssh-key%EF%BC%9A%E4%B8%A4%E4%B8%AA%E7%AE%80%E5%8D%95%E6%AD%A5%E9%AA%A4%E5%AE%9E%E7%8E%B0ssh%E6%97%A0%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95" target="_blank" rel="noopener">ssh-key：两个简单步骤实现ssh无密码登录</a>
</li>
<li><a href="http://manpages.ubuntu.com/manpages/precise/man1/ssh-copy-id.1.html" target="_blank" rel="noopener">Ubuntu anpages ssh-copy-id</a>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常用的 &lt;code&gt;ssh&lt;/code&gt; 或者 &lt;code&gt;scp&lt;/code&gt; 命令一般都会选择配置免密码登录，不然每次输入密码会挺痛苦的。&lt;br&gt;但现在有了更方便的操作方法，一个方便的命令 &lt;strong&gt;&lt;code&gt;ssh-copy-id&lt;/code&gt;&lt;/strong&gt;，特此记录备忘。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://yabzhang.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>review-基本算法</title>
    <link href="https://yabzhang.github.io/2017/08/05/review-%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/"/>
    <id>https://yabzhang.github.io/2017/08/05/review-基本算法/</id>
    <published>2017-08-05T13:06:23.000Z</published>
    <updated>2018-08-02T17:38:33.846Z</updated>
    
    <content type="html"><![CDATA[<p>复习基础算法（基本的排序和查找算法）。<br><a id="more"></a></p>
<h3 id="basic-algo"><a href="#basic-algo" class="headerlink" title="basic algo."></a>basic algo.</h3><p>谈到基本算法肯定就是排序和查找了，那就具体来看下这些基本的排序和查找算法；</p>
<h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>基本的排序算法包括：<br>１. 冒泡排序<br>２. 选择排序<br>３. 插入排序<br>４. 希尔排序<br>５. 归并排序<br>６. 快排</p>
<p>排序算法分为稳定和非稳定两类。<br>稳定排序算法的复杂度不会因序列有所改变；<br>而非稳定排序的算法复杂度会因特定的原因导致算法执行效率下降，复杂度增加；<br>比较型排序算法的Big-O复杂度一般不会低于<code>O(nlogn)</code>；</p>
<ul>
<li>冒泡排序</li>
</ul>
<p>冒泡排序是稳定排序，复杂度<code>O(n^2)</code>;<br>排序时，依次遍历序列，两两比较。若后者大于前者则交换顺序，否则继续下一组比较；<br>当一轮遍历完成后，最大的元素就会被交换到序列的最后一位，整个过程就像冒泡一样；<br>之后继续进行下一轮遍历，比较和交换位置。具体过程同上；<br>若某一次遍历完成后，并没有元素需要交换位置，那么排序就完成了；<br>遍历过程，最少一次，最多n次;</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(seq)</span>:</span></span><br><span class="line">    done = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(seq) - <span class="number">1</span>):</span><br><span class="line">        done = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(seq) - i):</span><br><span class="line">            <span class="keyword">if</span> seq[j] &lt; seq[j - <span class="number">1</span>]:</span><br><span class="line">                seq[j], seq[j - <span class="number">1</span>] = seq[j - <span class="number">1</span>], seq[j]</span><br><span class="line">                done = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> done:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> seq</span><br></pre></td></tr></table></figure>
<ul>
<li>选择排序</li>
</ul>
<p>选择排序是稳定排序,复杂度<code>O(n^2)</code>;<br>选择排序就像字面意思一样，每次从剩余列表中选择出最小的元素排在前面；<br>具体的过程就像小学做操的时候，每次排队，老师都找到最矮的排在前面，全部过程结束后，就排好了队；<br>这里在排序时，也是每次都找到剩余部分最小的元素，然后将最小的元素与其应该在的位置上的元素交换即可；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span><span class="params">(seq)</span>:</span></span><br><span class="line">    smallest = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(seq) - <span class="number">1</span>):</span><br><span class="line">        smallest = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(seq)):</span><br><span class="line">            <span class="keyword">if</span> seq[j] &lt; seq[smallest]:</span><br><span class="line">                smallest = j</span><br><span class="line">        seq[i], seq[smallest] = seq[smallest], seq[i]</span><br><span class="line">    <span class="keyword">return</span> seq</span><br></pre></td></tr></table></figure>
<ul>
<li>插入排序</li>
</ul>
<p>插入排序是稳定排序，复杂度<code>O(n^2)</code>;<br>插入排序时先分出一部分序列是拍好序的，然后每次从未排序的部分取出元素插入到已排序的部分中应该在的位置；<br>一直持续这个过程，直到所有的未排序全部都插入到已排序列中，排序完成；<br>在代码实现中，选择以交换的方式来移动位置；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(seq)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(seq)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> seq[j] &lt; seq[j - <span class="number">1</span>]:</span><br><span class="line">                seq[j], seq[j - <span class="number">1</span>] = seq[j - <span class="number">1</span>], seq[j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> seq</span><br></pre></td></tr></table></figure>
<ul>
<li>希尔排序</li>
</ul>
<p>希尔排序是插入排序的升级版，目的是为了减少排序时的移位操作；<br>具体的做法是先把待排序列分成一定间隔的元素组成的子序列，使用插入排序完成子序列的排序；<br>然后进一步减少分组数目，重新分配子序列，再次重复上述过程；<br>最后分组数目减少为１时，就与插入排序相同了；但移位操作可以有效减少；<br>最坏复杂度为<code>O(n^2)</code>；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(seq)</span></span></span><br><span class="line">    sub_cnt = len(seq) // 2</span><br><span class="line">    <span class="keyword">while</span> sub_cnt &gt; <span class="number">0</span>:  <span class="comment"># 最小为１个分组</span></span><br><span class="line">        <span class="keyword">for</span> start <span class="keyword">in</span> range(sub_cnt):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start + sub_cnt, len(seq), sub_cnt):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(i, start, -sub_cnt):</span><br><span class="line">                    <span class="keyword">if</span> seq[j] &lt; seq[j - sub_cnt]:</span><br><span class="line">                        seq[j], sq[j - sub_cnt] = seq[sub_cnt], seq[j]</span><br><span class="line">        sub_cnt = sub_cnt // <span class="number">2</span>  <span class="comment"># 减少分组</span></span><br><span class="line">    <span class="keyword">return</span> sub_cnt</span><br></pre></td></tr></table></figure>
<ul>
<li>归并排序</li>
</ul>
<p>归并排序使用了分治的思想，把问题分解为子问题，然后递归这个过程。<br>直到最终的子问题容易解决，然后把结果合并；最后通过合并子问题的结果，得到原有问题的解答；<br>归并排序是稳定排序，算法复杂度为<code>O(nlogn)</code>,需要额外的存储空间<code>O(n)</code>；</p>
<p>排序过程，先选择一个基准元素，与基准元素比较把列表分为两自列表：小于基准元素和大于等于基准元素。<br>之后对两自列表重复递归上述过程；最后可以得到长度为１子列表，可以认为这样的列表是已排序的；<br>然后把排好序的列表收集起来，最终得到排好序的列表；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(seq)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(seq) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> seq</span><br><span class="line"></span><br><span class="line">    mid = len(seq) // <span class="number">2</span></span><br><span class="line">    left = merge_sort(seq[:mid])</span><br><span class="line">    right = merge_sort(seq[mid:])</span><br><span class="line"></span><br><span class="line">    cnt, m, n = [<span class="number">0</span>] * <span class="number">3</span></span><br><span class="line">    <span class="keyword">while</span> m &lt; len(left) <span class="keyword">and</span> n &lt; len(right):</span><br><span class="line">        <span class="keyword">if</span> left[m] &lt;= right[n]:</span><br><span class="line">            seq[cnt] = left[m]</span><br><span class="line">            m += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            seq[cnt] = right[n]</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> m &lt; len(left):</span><br><span class="line">        <span class="keyword">while</span> m &lt; len(left) <span class="keyword">and</span> cnt &lt; len(seq):</span><br><span class="line">            seq[cnt] = left[m]</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            m += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> n &lt; len(right):</span><br><span class="line">        <span class="keyword">while</span> n &lt; len(right) <span class="keyword">and</span> cnt &lt; len(seq):</span><br><span class="line">            seq[cnt] = right[n]</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> seq</span><br></pre></td></tr></table></figure>
<ul>
<li>快排</li>
</ul>
<p>快排是非稳定排序，一般情况时算法的复杂度为<code>O(n)</code>；<br>但若是在最坏情况下，算法复杂度会退化到<code>O(n^2)</code>；<br>快排的过程，每一次迭代会从序列中选出一个基准元素，然后以此基准把序列分为较小(左)和较大(右)的两部分；<br>然后再分别对这两部分重复此过程；最后得到排好的序列；</p>
<p>最坏情况出现在每次选择基准元素均选中了最小或最大的元素，这样序列就不能成功地分为两部分；<br>复杂度就会退化为<code>O(n^2)</code>的复杂度；所以一般选择使用随机数来选择基准元素，尽量避免最坏情况的出现；</p>
<p>采用原地快排可以节省额外空间的使用；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(seq, start, end)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> end - start &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    base = random.randint(start, end)</span><br><span class="line">    seq[start], seq[base] = seq[base], seq[start]</span><br><span class="line"></span><br><span class="line">    pivot, cnt = start, start</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(start + <span class="number">1</span>, end + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> seq[i] &lt; seq[pivot]:</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            seq[cnt] = seq[i]</span><br><span class="line">    seq[pivot], seq[cnt] = seq[cnt], seq[pivot]</span><br><span class="line"></span><br><span class="line">    quick_sort(seq, start, cnt - <span class="number">1</span>)</span><br><span class="line">    quick_sort(seq, cnt + <span class="number">1</span>, end)</span><br><span class="line">    <span class="keyword">return</span> seq</span><br></pre></td></tr></table></figure>
<h4 id="search"><a href="#search" class="headerlink" title="search"></a>search</h4><p>基本的查找算法：顺序查找和二分查找；</p>
<ul>
<li>顺序查找</li>
</ul>
<p>顾名思义，就是按照顺序查找；复杂度<code>O(n)</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sequential_search</span><span class="params">(seq, item)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(seq)):</span><br><span class="line">        <span class="keyword">if</span> seq[i] == item:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>二分查找</li>
</ul>
<p>二分查找，算法复杂度为<code>O(logn)</code>；<br>要求序列是有序的；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bin_search</span><span class="params">(seq, item)</span>:</span></span><br><span class="line">    start, end = <span class="number">0</span>, len(seq) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> seq[mid] &gt; item:</span><br><span class="line">            end = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> seq[mid] &lt; item:</span><br><span class="line">            start = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="the-end"><a href="#the-end" class="headerlink" title="the end"></a>the end</h3><p>基本算法：</p>
<p>６种基本排序算法；<br>比较型排序算法最快不会小于<code>O(nlogn)</code>；</p>
<p>两种基本查找算法，其中二分查找要求序列有序。</p>
]]></content>
    
    <summary type="html">
    
      基础算法
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>review-基本数据结构</title>
    <link href="https://yabzhang.github.io/2017/08/05/review%EF%BC%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://yabzhang.github.io/2017/08/05/review－基本数据结构/</id>
    <published>2017-08-05T06:23:49.000Z</published>
    <updated>2018-08-02T17:38:33.847Z</updated>
    
    <content type="html"><![CDATA[<p>复习基础的数据结构（栈，队列，链表）。<br><a id="more"></a></p>
<h3 id="basic-data-structure"><a href="#basic-data-structure" class="headerlink" title="basic data structure"></a>basic data structure</h3><ul>
<li>Stack</li>
</ul>
<p>栈(Stack)，是一种支持后进先出(LIFO)的基本数据结构，可以使用数组或者链表实现；<br>支持的基本操作包括：<code>push</code>, <code>pop</code>, <code>size</code>, <code>is_empty</code>, <code>peek</code>;</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回元素数量"""</span></span><br><span class="line">        <span class="keyword">return</span> len(self.items)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""判断当前栈中是否为空"""</span></span><br><span class="line">        <span class="keyword">return</span> self.size() == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""向栈中压入元素"""</span></span><br><span class="line">        self.items.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""从栈中弹出元素，若为空栈则抛出ValueError异常"""</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Empty Stack'</span>)</span><br><span class="line">        <span class="keyword">return</span> self.items.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回栈顶元素，并不弹出，若为空栈则抛出ValueError异常"""</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Empty Stack'</span>)</span><br><span class="line">        <span class="keyword">return</span> self.items[<span class="number">-1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>栈结构的后入先出的特性有很多用途，如程序函数调用时就使用栈结构来保存现场，表达式句法分析时也会用到栈。</p>
<ul>
<li>Queue</li>
</ul>
<p>队列(queue)，是支持先进先出(FIFO)的基本数据结构，同样可以使用数组或者链表实现；<br>支持的基本操作包括：<code>enqueue</code>, <code>dequeue</code>, <code>size</code>, <code>is_empty</code>;</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回队列中元素数量"""</span></span><br><span class="line">        <span class="keyword">return</span> len(self.items)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""判断队列是否为空"""</span></span><br><span class="line">        <span class="keyword">return</span> self.size() == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""向队列添加一个元素"""</span></span><br><span class="line">        self.items.insert(<span class="number">0</span>, item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""从队列返回一个元素，若为空队列则抛出ValueError异常"""</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Empty Queue'</span>)</span><br><span class="line">        <span class="keyword">return</span> self.items.pop()</span><br></pre></td></tr></table></figure>
<p>队列结构有很多的衍生结构，如双端队列，优先级队列等。<br>队列结构可以保证元素按照入队列的顺序出队列，在实际使用中，也多用于实现有顺序要求的任务或消息流等；</p>
<ul>
<li>Linked List</li>
</ul>
<p>链表(Linked List), 是使用的最广泛的数据结构。<br>链表，数组或Python中的列表都是线性数据结构，但数组或列表元素在内存中位置是连续的，而链表元素间是通过指针或者索引联系起来的，而且只有相邻的元素间才会有联系；<br>这就意味着，对于数组或者列表，只要知道了某元素的索引和起始的位置可以通过内存偏移量访问到该元素，而对于链表只能通过相邻的元素来访问，对于随机访问只能从头遍历来寻找到指定元素；</p>
<p>对比链表与数组，数组在索引方面更有优势，适合于读操作较多的场景；而链表在创建和删除新元素方面没有存储方面的限制，更适合大量写操作的场景；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""链表节点元素类"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data, next=None)</span>:</span></span><br><span class="line">        self._data = data</span><br><span class="line">        self._next = next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""获取节点数据"""</span></span><br><span class="line">        <span class="keyword">return</span> self._data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""获取下一个节点"""</span></span><br><span class="line">        <span class="keyword">return</span> self._next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_data</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        <span class="string">"""设置节点数据"""</span></span><br><span class="line">        self._data = val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_next</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        ”“”设置节点下一个指向元素<span class="string">"""</span></span><br><span class="line"><span class="string">        self._next = node</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class SingleLinkedList(object):</span></span><br><span class="line"><span class="string">    """</span>单链表<span class="string">"""</span></span><br><span class="line"><span class="string">    def __init__(self):</span></span><br><span class="line"><span class="string">        self.head = None</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def is_empty(self):</span></span><br><span class="line"><span class="string">        ”“”判断是否为空"""</span></span><br><span class="line">        <span class="keyword">return</span> self.head == <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""增加新节点"""</span></span><br><span class="line">        tmp_node = Node(item)</span><br><span class="line">        tmp_node.set_next(self.head)</span><br><span class="line">        self.head = tmp_node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回链表节点数"""</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            cur = cur.get_next()</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""在链表中搜索指定数据的节点"""</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        found = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.get_data() == item:</span><br><span class="line">                <span class="keyword">return</span> cur</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.get_next()</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""删除链表中指定数据的节点"""</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        prev = <span class="keyword">None</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.get_data() == item:</span><br><span class="line">                <span class="keyword">if</span> prev <span class="keyword">is</span> <span class="keyword">None</span>:  <span class="comment"># head match</span></span><br><span class="line">                    self.set_head(cur.get_next())</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    prev.set_next(cur.get_next())</span><br><span class="line">                    prev = cur</span><br><span class="line">                cur = cur.get_next()</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev = cur</span><br><span class="line">                cur = cur.get_next()</span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>
<p>链表是使用的最广泛的数据结构之一，相关的话题和衍生的结构甚至不是一两篇文章可以讲得清的。<br>数据结构和算法是基本功，而链表更是数据结构中最基本的部分，需要投入时间和精力进行足够地了结。<br>之后专门写下树和图结构，判断链表是否有环的分析；</p>
<h3 id="the-end"><a href="#the-end" class="headerlink" title="the end"></a>the end</h3><p>基本的数据结构：</p>
<p>栈：后进先出(LIFO)，支出入栈和出栈等基本操作；<br>队列：先进先出(FIFO)，支持如队列和出队列等基本操作；<br>链表：元素间以指针或索引关联，头结点，节点元素；</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;复习基础的数据结构（栈，队列，链表）。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>buildout构建工具</title>
    <link href="https://yabzhang.github.io/2017/07/25/buildout%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    <id>https://yabzhang.github.io/2017/07/25/buildout构建工具/</id>
    <published>2017-07-25T00:40:10.000Z</published>
    <updated>2018-08-02T17:38:33.845Z</updated>
    
    <content type="html"><![CDATA[<p><code>buildout</code>构建工具的使用记录。<br><a id="more"></a></p>
<h3 id="prologue"><a href="#prologue" class="headerlink" title="prologue"></a>prologue</h3><blockquote><p>Buildout is a tool for automating software assembly.</p>
<ul>
<li>Run build tools to build software.</li>
<li>Apply software and templates to generate configuration files and scripts.</li>
<li>Application to all software phases, from development to production deployment.</li>
<li>Based on core priciples:<ol>
<li>Repeatability</li>
<li>Componentization</li>
<li>Automation</li>
</ol>
</li>
</ul>
<footer><strong>buildout doc,</strong><cite><a href="http://docs.buildout.org" target="_blank" rel="noopener">docs.buildout.org</a></cite></footer></blockquote>
<p>buildout的是一款自动化构建工具。<br>由<code>Zope</code>团队开发维护。包名为<code>zc.buildout</code>。</p>
<p><code>buildout</code>可以为应用构建独立的依赖环境。类似于<code>virtualenv</code>，但二者还有不同。<br>粗略地讲，<code>buildout</code>支持的功能更多更便于自动化而且具体定位有所不同。</p>
<h3 id="use-case"><a href="#use-case" class="headerlink" title="use case"></a>use case</h3><h4 id="install-buildout"><a href="#install-buildout" class="headerlink" title="install buildout"></a>install buildout</h4><ul>
<li>首先是安装buildout</li>
</ul>
<p><code>pip install zc.buildout</code></p>
<p>使用<code>pip</code>安装<code>zc.buildout</code>包。</p>
<ul>
<li>为项目配置buildout</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd project</span><br><span class="line">buildout init</span><br></pre></td></tr></table></figure>
<p><code>buildout init</code>在项目目录中初始化。初始化后，目录下会多出一些目录和文件。<br>其中<code>buildout.cfg</code>是默认的<code>buildout</code>配置文件。具体的配置留待下文介绍。</p>
<p><code>buildout init</code>会采用当前默认的python环境。也可以在隔离环境（如:<code>virtualenv</code>）中运行。<br>而且<code>buildout init</code>初始化并不会提供<code>bootstrap.py</code>文件。<br>这个文件由官方提供，为了便于自动化需要下载这个文件，并加到版本控制中。<a href="https://bootstrap.pypa.io/bootstrap-buildout.py" target="_blank" rel="noopener">传送门</a></p>
<p>基本的安装工作到这里就完成了。下面来看看如何使用<code>buildout</code>来构建一个环境。</p>
<ul>
<li>使用buildout构建应用环境</li>
</ul>
<p>假定我们需要在一台新的机器上构建<code>buildout</code>应用环境。<br>我们只需要进入项目目录，运行启动<code>bootstrap.py</code>脚本即可。<br><code>bootstrap.py</code>会自行完成<code>buildout</code>和依赖的安装，并按照<code>buildout.cfg</code>配置内容完成构建。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd project</span><br><span class="line">python bootstrap.py</span><br></pre></td></tr></table></figure>
<p>前文提到<code>buildout</code>可以在系统环境或隔离环境(如:<code>virtualenv</code>)构建具体的应用环境。<br>官方推荐在沙盒环境中构建:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">virtualenv -p python3 project</span><br><span class="line">cd project</span><br><span class="line">bin/python bootstrap.py</span><br></pre></td></tr></table></figure>
<p>目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">project/</span><br><span class="line">   bootstrap.py  †</span><br><span class="line">   buildout.cfg  †</span><br><span class="line">   .installed.cfg</span><br><span class="line">   parts/</span><br><span class="line">   develop-eggs/</span><br><span class="line">   bin/</span><br><span class="line">       buildout</span><br><span class="line">       mypython</span><br><span class="line">   eggs/</span><br><span class="line">   downloads/</span><br></pre></td></tr></table></figure>
<p>只有<code>bootstrap.py</code>和<code>buildout.cfg</code>需要加入到代码库。</p>
<h4 id="buildout-cfg配置"><a href="#buildout-cfg配置" class="headerlink" title="buildout.cfg配置"></a>buildout.cfg配置</h4><ul>
<li>简单的demo:</li>
</ul>
<script src="//gist.github.com/5adfe037c44555d4c2b4cebfe55eb2a9.js"></script>
<p><code>[buildout]</code>这个块是必需的，可以在此指定起用的配置块信息；<br><code>parts</code>中指定起用的块名字，数目任意，一行一个；<br><code>develop</code>用于指定创建<code>egg</code>包的目录，指定目录必须包含一个<code>setup.py</code>文件用于打包。</p>
<p><code>[event]</code>是自定义块；如<code>[event]</code>，<code>[server]</code>…<br><code>recipe</code>对自定义块是必需的，可以是分发好的包，也可以自行制作。<br>最常用的就是<code>zc.recipe.egg</code>，用于按照块定义打包(egg)。<br>包含了完成块定义逻辑代码，如安装依赖、生成脚本等。<br><code>eggs</code>指定了需要加载的egg包以及相关的依赖。<br><code>interpreter</code>会创建一个包含eggs和依赖的执行环境，在<code>bin</code>目录下。</p>
<p>更多选项参考文档。</p>
<ul>
<li>配置实例：</li>
</ul>
<script src="//gist.github.com/d172d3f67336ba1891dce2646cf5dfdd.js"></script>
<p><code>[buildout]</code>起用了<code>project</code>块，并在当前境目录打包。<br><code>[project]</code>用于创建一个’project’的包，并提供一个执行环境。<br><code>extra-paths</code>选项的值，为一个或多个路径，会被添加到环境解释器的搜索路径中。<br><code>{buildout:directory}</code>值为当前构建目录。<br><code>[versions]</code>部分指定依赖的版本要求。</p>
<p><code>develop</code>指定的打包目录中必须包含<code>setup.py</code>文件用于打包。<br><code>setup.py</code>文件包含了所有打包必须的信息，如版本，依赖，和入口等。<br><code>install_requires</code>中指定了依赖，如果缺失会使用<code>pip</code>安装。这里我采用了在<code>buildout.cfg</code>中进行包的版本管理。<br><code>entry_points</code>中指明了包的入口，<code>buildout</code>会创建一个此入口的启动脚本在<code>bin</code>目录下。</p>
<p><code>setup.py</code>的配置，又是另外一个话题了。更多选项参考文档。</p>
<ul>
<li><p>项目中的实例</p>
<p>  <a href="https://github.com/YabZhang/tornado_base" target="_blank" rel="noopener">传送门</a></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/YabZhang/tornado_base</span><br><span class="line">cd torando_base</span><br><span class="line"></span><br><span class="line"># install &amp;&amp; buildout</span><br><span class="line">python bootstrap.py</span><br><span class="line"></span><br><span class="line"># start server</span><br><span class="line">bin/server</span><br></pre></td></tr></table></figure>
<p>然后，就可以滚去写代码了…</p>
<h3 id="the-end"><a href="#the-end" class="headerlink" title="the end"></a>the end</h3><p><code>buildout</code>适用于自动化构建，能够有效提高工作效率。推荐与<code>virtualenv</code>一起使用。<br>功能上与<code>docker</code>和<code>make</code>有所重叠，好在简单快捷，也能很好地满足中小项目的需要，没做过大项目-.-;</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;buildout&lt;/code&gt;构建工具的使用记录。&lt;br&gt;
    
    </summary>
    
    
      <category term="buildout" scheme="https://yabzhang.github.io/tags/buildout/"/>
    
      <category term="automation" scheme="https://yabzhang.github.io/tags/automation/"/>
    
  </entry>
  
  <entry>
    <title>hexo标签体验</title>
    <link href="https://yabzhang.github.io/2017/07/23/hexo%E6%A0%87%E7%AD%BE%E4%BD%93%E9%AA%8C/"/>
    <id>https://yabzhang.github.io/2017/07/23/hexo标签体验/</id>
    <published>2017-07-22T17:34:12.000Z</published>
    <updated>2018-08-02T17:38:33.846Z</updated>
    
    <content type="html"><![CDATA[<p><code>hexo</code>模板标签使用之初体验。<br><a id="more"></a></p>
<h3 id="prologue"><a href="#prologue" class="headerlink" title="prologue"></a>prologue</h3><p> 今天搭好了hexo的博客，选了一个风格偏简化的主题。<br> 那么接下来就来测试下hexo的标签插件的具体效果。</p>
<h3 id="tag-test"><a href="#tag-test" class="headerlink" title="tag test"></a>tag test</h3><p> hexo的标签插件主要用于在文章中快速插入特定的内容。写法上有点像是jinja这样的模板语言。<br> 参考hexo文档，其标签插件包括引用、代码高亮和插入外链和图片的功能外，还支持文件代码引入，iframe, gist和youtube视频插入等。</p>
<h4 id="引用块"><a href="#引用块" class="headerlink" title="引用块"></a>引用块</h4><p> 在文章中插入引用块，可以包含作者、来源和标题。</p>
 <blockquote><p>引用块测试。</p>
<footer><strong>Yabin Zhang</strong><cite>Yabin Zhang's Blog</cite></footer></blockquote>
 <blockquote><p>再次引用块测试。</p>
<footer><strong>Yabin Zhang</strong></footer></blockquote>
 <blockquote><p>Try in English.</p>
<footer><strong>Yab Zhang</strong><cite><a href="https://yabzhang.github.io,">Test Plugin</a></cite></footer></blockquote>
<p> 引用块标识来源的展示有点问题。</p>
<h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p> 普通代码块<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(&apos;Hello, World&apos;);</span><br></pre></td></tr></table></figure></p>
<p> 指定语言<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]  <span class="comment"># Python</span></span><br></pre></td></tr></table></figure></p>
 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[rectangle setX: <span class="number">10</span> y: <span class="number">10</span> width: <span class="number">20</span> height: <span class="number">20</span>];  <span class="comment">// objc</span></span><br></pre></td></tr></table></figure>
<p> 附加说明<br> <figure class="highlight python"><figcaption><span>generator</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator</span><span class="params">(seq)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> range(seq):</span><br><span class="line">        <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure></p>
 <figure class="highlight js"><figcaption><span>Array.map</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight c"><figcaption><span>printf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello, World\n"</span>);</span><br></pre></td></tr></table></figure>
<p> 指明代码块的语言后可以语法高亮；<br> 不过附加说明的样式不是很满意。</p>
<h4 id="反引号代码块"><a href="#反引号代码块" class="headerlink" title="反引号代码块"></a>反引号代码块</h4> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">funciton print_log(item) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@decorator</span><br><span class="line">def logic_handler(a, *args, **kwargs):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<h4 id="Gist插入"><a href="#Gist插入" class="headerlink" title="Gist插入"></a>Gist插入</h4> <script src="//gist.github.com/d172d3f67336ba1891dce2646cf5dfdd.js"></script>
<p> gist插入的特性挺棒的，但是在gist中包含多个文件时，指定文件名展示失败；</p>
<h4 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h4><p> 资源文件引用：<br> <img src="/2017/07/23/hexo标签体验/ayanami.jpg" title="local file"></p>
<p> 外链图片, 可指定大小:<br> <img src="http://icons.iconarchive.com/icons/artcore-illustrations/artcore-4/512/github-icon.png" width="200" height="200"></p>
<h4 id="外链"><a href="#外链" class="headerlink" title="外链"></a>外链</h4> <a href="https://hexo.io/zh-cn/doc" target="_blank" rel="noopener">Hexo So Cool</a>
<h4 id="插入代码文件"><a href="#插入代码文件" class="headerlink" title="插入代码文件"></a>插入代码文件</h4>  
<p> 代码文件展示失败，又或者我姿势不对。</p>
<h4 id="插入youtube视频"><a href="#插入youtube视频" class="headerlink" title="插入youtube视频"></a>插入youtube视频</h4><p>  昨天看到Linkin Park主唱自杀的消息，感到特别惋惜。<br>  在我最黑暗的时候，那壮怀激烈的歌声不止一次地给我希望。<br>  给世界都来了那么多光明，却没一缕光能留得住你。<br>  一路好走。</p>
  <div class="video-container"><iframe src="//www.youtube.com/embed/kXYiU_JCYtU" frameborder="0" allowfullscreen></iframe></div>
<h3 id="end"><a href="#end" class="headerlink" title="end"></a>end</h3><p>  以上就是对新博客的测试。<br>  有些地方还有瑕疵，但整体上还比较满意。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;hexo&lt;/code&gt;模板标签使用之初体验。&lt;br&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://yabzhang.github.io/tags/hexo/"/>
    
      <category term="tags" scheme="https://yabzhang.github.io/tags/tags/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://yabzhang.github.io/2017/07/23/hello-world/"/>
    <id>https://yabzhang.github.io/2017/07/23/hello-world/</id>
    <published>2017-07-22T16:00:00.000Z</published>
    <updated>2018-08-02T17:38:33.846Z</updated>
    
    <content type="html"><![CDATA[<p>Hello, World<br><a id="more"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hello, World&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
