<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yab Zhang&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yabzhang.github.io/"/>
  <updated>2018-10-08T16:26:47.481Z</updated>
  <id>https://yabzhang.github.io/</id>
  
  <author>
    <name>Yab Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>celery延时任务踩坑</title>
    <link href="https://yabzhang.github.io/2018/10/08/celery%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%B8%A9%E5%9D%91/"/>
    <id>https://yabzhang.github.io/2018/10/08/celery延时任务踩坑/</id>
    <published>2018-10-08T15:19:46.000Z</published>
    <updated>2018-10-08T16:26:47.481Z</updated>
    
    <content type="html"><![CDATA[<p><code>celery</code>的延时任务参数<code>countdown</code>或者<code>eta</code> 清晰易懂，使用起来也很方便；但最近遇到一个坑。</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 120s 后执行任务</span></span><br><span class="line">task.apply_async(args, countdown=<span class="number">120</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 120s 后执行任务</span></span><br><span class="line">task_dt = datetime.datetime.now() + datetime.timedelta(seconds=<span class="number">120</span>)</span><br><span class="line">task.apply_async(args, eta=task_dt)</span><br></pre></td></tr></table></figure>
<p><code>celery</code>的延时任务调用真的很简单。</p>
<p>延时8小时后执行是项目的一个功能，但是实际到预定时间后任务被重复执行;<br>其中最主要的原因是测试不完全；但具体的原因还是技术在使用celery延时任务这里踩了坑,其实官方文档里已经有提过;</p>
<p>celery官方文档中有提到使用redis作为broker时，需要注意的问题；</p>
<blockquote><p><strong>Visibility timeout</strong></p>
<p><em>If a task isn’t acknowledged within the Visibility Timeout the task will be redelivered to another worker and executed.</em><br>如果一个任务没有在<code>visibility timeout</code>时间内被确认，就会被重新分发到另一个<code>worker</code>去执行.</p>
<p><em>This causes problems with ETA/countdown/retry tasks where the time to execute exceeds the visibility timeout; in fact if that happens it will be executed again, and again in a loop.</em><br>这会让采用了<code>etc/countdown/retry</code>这些特性并且超时没有确认的任务出问题，具体就是任务被重复地执行。</p>
<p><em>So you have to increase the visibility timeout to match the time of the longest ETA you’re planning to use.</em><br>所以，你必须增加<code>visibility timeout</code>的配置值来覆盖你打算使用的最长<code>eta</code>延时时间。</p>
<p><em>Note that Celery will redeliver messages at worker shutdown, so having a long visibility timeout will only delay the redelivery of ‘lost’ tasks in the event of a power failure or forcefully terminated workers.</em><br>需要注意的是，<code>celery</code>会在<code>worker</code>关闭的时候重新分发任务，所以配置一个较长的<code>visibility timeout</code>值只会让那些“丢失”的任务延迟执行，就比如在服务器停电或者<code>worker</code>被暴力中止时导致的任务丢失。</p>
<p>Periodic tasks won’t be affected by the visibility timeout, as this is a concept separate from ETA/countdown.<br>周期性任务不受这个配置影响，因为周期任务的原理不同于<code>eta/countdown</code>这样的延时任务。</p>
<p>You can increase this timeout by configuring a transport option with the same name:<br>你可以这样配置这个值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.conf.broker_transport_options = &#123;<span class="string">‘visibility_timeout’</span>: <span class="number">43200</span>&#125;  <span class="comment"># 12h</span></span><br></pre></td></tr></table></figure>

<p>The value must be an int describing the number of seconds.<br>配置值必须是整数，表示总的秒数;</p>
</blockquote>
<p>因为redis作为broker时，<code>visibility timeout</code>的默认值是一小时，所以延时任务被重复执行的问题就发生了。<br>每个小时未被确认的任务被重新分发到新的worker里去执行；这样到了预定的时间，就会有很多个待执行任务；<br>通过把<code>visibility timeout</code>减少到很短的时间，可以复现问题；而解决方法也就是把这个配置的值调到足够得大。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;celery&lt;/code&gt;的延时任务参数&lt;code&gt;countdown&lt;/code&gt;或者&lt;code&gt;eta&lt;/code&gt; 清晰易懂，使用起来也很方便；但最近遇到一个坑。&lt;/p&gt;
    
    </summary>
    
    
      <category term="-- celery" scheme="https://yabzhang.github.io/tags/celery/"/>
    
  </entry>
  
  <entry>
    <title>revert一个merge提交</title>
    <link href="https://yabzhang.github.io/2018/08/20/revert%E4%B8%80%E4%B8%AAmerge%E6%8F%90%E4%BA%A4/"/>
    <id>https://yabzhang.github.io/2018/08/20/revert一个merge提交/</id>
    <published>2018-08-19T16:27:48.000Z</published>
    <updated>2018-08-19T17:00:38.939Z</updated>
    
    <content type="html"><![CDATA[<p><code>git</code>是最常用的代码版本管理工具，撤销已经提交的代码的操作包括：<code>git checkout</code>、<code>git reset</code>、<code>git revert</code>。我再使用<code>revert</code>撤销一个合并后，遇到了一些特别的情况。</p>
<a id="more"></a>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol>
<li><p><code>git checkout</code> 主要用于本地代码库的分支切换，和调到指定的提交快照。但并不改变分支的记录和<code>HEAD</code>的位置。</p>
</li>
<li><p><code>git reset</code> 主要用于本地代码的撤销操作，是可以改变提交历史的和<code>HEAD</code>指针位置的。例如：<code>git reset &lt;commit-hash&gt;</code>，将会把当前分支到指定的提交前全部撤销，并改变分支<code>HEAD</code>指针的位置。这个命令可能具有破坏性，请谨慎使用。对于丢失的提交记录可以尝试使用<code>git reflog</code>来找回。</p>
</li>
<li><p><code>git revert</code>的效果是增加一个提交(<code>HEAD</code> 自然前移一个位置)，<code>抵消</code>掉要回退的代码提交，但不改变已有的提交历史，注意这个命令与<code>git reset</code>的区别。</p>
</li>
</ol>
<h3 id="revert一个合并提交"><a href="#revert一个合并提交" class="headerlink" title="revert一个合并提交"></a><code>revert</code>一个合并提交</h3><p><code>git checkout</code>和<code>git reset</code>的使用请参考手册和各种资料。这里记录下我再使用<code>revert</code>时遇到的一个特别情况。</p>
<p><code>git revert &lt;commit-hash&gt;</code>的效果是新增一个提交，用于抵消掉某个历史提交。具体的逻辑就是在这个提交里添加历史提交相反的代码改动来回退代码，但不会改变已有的历史。</p>
<p>一个特别的情况: 有一个功能分支<code>feature-a</code>在合并到<code>master</code>后，发现新功能有隐藏的bug。<br>所以在<code>master</code>上使用<code>git revert</code>来回退这个合并，并在<code>feature-a</code>上尽心修复。<br>待修复胡再尝试将<code>feature-a</code>合并到<code>master</code>会因为<code>revert</code>而无法改变当前代码。</p>
<p>原因就是<code>revert</code>并没有改变历史，所以在<code>master</code>历史上是有新功能的提交的（但已经被回退了），所以简单的再次合并不能生效。</p>
<p>在网络上找到了<code>linus</code>回答的解决方案：</p>
<ol>
<li><p>在<code>master</code>上再进行一次<code>revert</code>操作，用于回退第一次的<code>revert</code>那个提交。然后再合并修复后的<code>feature-a</code>到<code>master</code>；</p>
</li>
<li><p>因为使用<code>revert</code>是保留历史的，所以需要重新构造已有的历史提交，尝试再次合并。简单来说就是把被撤销的代码放在新的提交中再合并;具体的做法很多，比如可以在修复前，从原有的<code>feature-a</code>重新生成新分支（<code>git rebase --no-ff</code>，会创建新的历史，提交的hash会改变），做修复操作后再合并会<code>master</code>就不会有问题。</p>
</li>
</ol>
<p>在文章中，linus给出的建议是优先方法2。因为方法1的做法不是正规的工作流方法(理解可能有偏差，文后有链接，请自行查看)。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://git-scm.com/docs/git-cherry-pick" target="_blank" rel="noopener">https://git-scm.com/docs/git-cherry-pick</a> Git资源</li>
<li><a href="https://www.atlassian.com/git/tutorials/learn-git-with-bitbucket-cloud" target="_blank" rel="noopener">https://www.atlassian.com/git/tutorials/learn-git-with-bitbucket-cloud</a> Git资源</li>
<li><a href="https://opensource.apple.com/source/Git/Git-26/src/git-htmldocs/howto/revert-a-faulty-merge.txt" target="_blank" rel="noopener">https://opensource.apple.com/source/Git/Git-26/src/git-htmldocs/howto/revert-a-faulty-merge.txt</a> linus的回答</li>
<li><a href="https://mijingo.com/blog/reverting-a-git-merge" target="_blank" rel="noopener">https://mijingo.com/blog/reverting-a-git-merge</a> revert一个合并提交</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;git&lt;/code&gt;是最常用的代码版本管理工具，撤销已经提交的代码的操作包括：&lt;code&gt;git checkout&lt;/code&gt;、&lt;code&gt;git reset&lt;/code&gt;、&lt;code&gt;git revert&lt;/code&gt;。我再使用&lt;code&gt;revert&lt;/code&gt;撤销一个合并后，遇到了一些特别的情况。&lt;/p&gt;
    
    </summary>
    
    
      <category term="-- git" scheme="https://yabzhang.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>celery 笔记(3)</title>
    <link href="https://yabzhang.github.io/2018/08/11/celery-%E7%AC%94%E8%AE%B0-3/"/>
    <id>https://yabzhang.github.io/2018/08/11/celery-笔记-3/</id>
    <published>2018-08-11T12:27:59.000Z</published>
    <updated>2018-08-12T07:01:43.020Z</updated>
    
    <content type="html"><![CDATA[<p>项目中用到了<code>celery</code>，最近踩了一些坑。花点时间整理下有关<code>celery</code>的知识。<br>本文是<code>celery</code>笔记的第三篇，主要记录下<code>celery</code>的最佳实践。<br><a id="more"></a></p>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>最佳实践主要源自一份网络博文, <a href="https://denibertovic.com/posts/celery-best-practices/" target="_blank" rel="noopener">传送门</a>。中文翻译版，辅助理解，<a href="http://www.cnblogs.com/ajianbeyourself/p/3889017.html#_label4" target="_blank" rel="noopener">传送门</a>。</p>
<ul>
<li>不要使用数据库作为</li>
</ul>
<p>作者说有不少人为了方便会使用数据库作为<code>broker</code>使用。但这样容易出问题，在性能上会有瓶颈，不利于拓展；也有可能影响到其他服务。例如：较多的工作节点可能会耗尽数据库连接；</p>
<ul>
<li>使用多个任务队列</li>
</ul>
<p>未指明队列的任务会使用默认的任务队列(可配置，不配置时默认是<code>celery</code>)。不同类型的任务最好分不同的任务队列，如：订单相关的任务和邮件发送，明显优先级不同，要分开处理。</p>
<ul>
<li>使用优先级<code>worker</code></li>
</ul>
<p>这条作者认为，为任务较多的队列部署更多的worker节点，使得量大的任务可以得到有效的处理。参见上一篇文章部署不同队列worker的方案。</p>
<p>此外，<code>celery</code>支持为同意队列的任务配置不同优先级, 高优先级的任务能先被处理。<code>celery</code>还支持定义优先级队列，场景是在某worker绑定多个任务队列时，优先处理较高优先级队列的任务，但只有少量<code>broker</code>支持，如rabbitmq，redis不支持。</p>
<ul>
<li>使用<code>celery</code>的错误处理机制</li>
</ul>
<p>建议使用<code>celery</code>的错误处理机制来处理失败等情况，例如：任务重试。</p>
<ul>
<li>使用<code>Flower</code></li>
</ul>
<p><code>Flower</code>是一个<code>celery</code>任务监控工具，可以方便地看到<code>broker</code>和<code>worker</code>的任务进度和实际的执行情况。</p>
<ul>
<li>忽略任务的结果，除非你真的需要</li>
</ul>
<p>很多的任务并不需要返回数据。任务状态也只有做统计时才用到。除非真的需要，一般可以忽略任务结果，具体配置为<code>CELERY_IGNORE_RESULT = True</code>。</p>
<ul>
<li>不要在任务调用中传参数据库对象或者orm对象</li>
</ul>
<p>主要是针对<code>python</code>的项目实践，传参数据库对象，最后任务中拿到的有可能已经是旧的数据。更好的做法是传数据条目的id。我认为是最好只把<code>python</code>的基本类型作为参数。</p>
<h3 id="可能的问题"><a href="#可能的问题" class="headerlink" title="可能的问题"></a>可能的问题</h3><ol>
<li>通过<code>task_id</code>获取任务结果</li>
</ol>
<p>每个任务都有一个唯一的<code>task_id</code>，可以由此获取任务的执行状态和执行的结果;使用<code>celery.result.AsyncResult</code>是一种较为通用的任务结果获取方式;<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tasks <span class="keyword">import</span> app</span><br><span class="line"><span class="keyword">from</span> celery.result <span class="keyword">import</span> AsyncResult</span><br><span class="line"></span><br><span class="line">task_id = <span class="string">"a9bab539-5c7a-4b24-8b19-1aea619cb6d5"</span>  <span class="comment"># mock task_id</span></span><br><span class="line">task_result = AsyncResult(task_id, app=app)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"status: "</span>, task_result.status)</span><br><span class="line">print(<span class="string">"result: "</span>, task_result.get(timeout=<span class="number">1</span>))  <span class="comment"># 1s timeout</span></span><br></pre></td></tr></table></figure></p>
<p>上述的<code>app</code>是声明的celery实例，在这里是必须的；<br>若缺失则会因为缺失配置上下文(例如：broker等)而获取任务结果失败;</p>
<p>更简单的获取方式，但需要明确任务的类型。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tasks <span class="keyword">import</span> add</span><br><span class="line"></span><br><span class="line">task_id = <span class="string">"a9bab539-5c7a-4b24-8b19-1aea619cb6d5"</span>  <span class="comment"># mock task_id</span></span><br><span class="line">result = add.AsyncResult(id=<span class="string">"copied_task_id"</span>)</span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li>合理配置任务队列和<code>worker</code>，添加任务监控</li>
</ol>
<p>根据可能任务量级配置足够的worker来处理任务，否则可能导致任务队列的任务堆积。最好可以添加任务的监控，例如<code>flower</code>等工具;</p>
<ol start="3">
<li>db session的更新问题</li>
</ol>
<p>这是我在<code>flask</code>项目中遇到的一个问题。任务中的db session异常，如：任务中的session无法查到新插入的数据；应该是和数据库的隔离级别有关。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@task_postrun.connect</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">close_session</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    <span class="comment"># this ensures tasks have a fresh session (e.g. session errors won't propagate across tasks)</span></span><br><span class="line">    db.session.remove()</span><br></pre></td></tr></table></figure>
<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>本文罗列了一些<code>celery</code>最佳实践, 并对可能会出的问题给出了解答。基本总结下来就是采用推荐配置，保持任务简单，区分不同的任务队列，添加监控。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目中用到了&lt;code&gt;celery&lt;/code&gt;，最近踩了一些坑。花点时间整理下有关&lt;code&gt;celery&lt;/code&gt;的知识。&lt;br&gt;本文是&lt;code&gt;celery&lt;/code&gt;笔记的第三篇，主要记录下&lt;code&gt;celery&lt;/code&gt;的最佳实践。&lt;br&gt;
    
    </summary>
    
    
      <category term="-- python -- celery" scheme="https://yabzhang.github.io/tags/python-celery/"/>
    
  </entry>
  
  <entry>
    <title>celery 笔记(2)</title>
    <link href="https://yabzhang.github.io/2018/08/10/celery-%E7%AC%94%E8%AE%B0-2/"/>
    <id>https://yabzhang.github.io/2018/08/10/celery-笔记-2/</id>
    <published>2018-08-09T16:16:33.000Z</published>
    <updated>2018-08-09T17:42:06.928Z</updated>
    
    <content type="html"><![CDATA[<p>项目中用到了<code>celery</code>，最近踩了一些坑。花点时间整理下有关<code>celery</code>的知识。<br>本文是<code>celery</code>笔记的第二篇，主要是<code>celery</code>的常见高级用法。</p>
<a id="more"></a>
<h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><p>在上一篇中，我们了解了<code>celery</code>的基本架构，以及作为任务队列的基本使用。<br>这里我们讲两个常见的高级用法，原语和任务路由。</p>
<p><code>celery</code>有很多高级的用法，例如：选择<code>rabbitmq</code>作为<code>broker</code>可以利用消息队列的一些高级特性，如队列的优先级等。</p>
<p>但这里我们只讲一些比较常规的高级用法，并没有特别的<code>broker</code>要求的。<br>我在描述和做demo时均使用redis作为broker和backend。</p>
<h4 id="工作流原语-workflow-primitives"><a href="#工作流原语-workflow-primitives" class="headerlink" title="工作流原语 (workflow primitives)"></a>工作流原语 (workflow primitives)</h4><ul>
<li>任务签名</li>
</ul>
<p>在说原语前，先简单说明下任务签名(signature)。</p>
<p>签名就像是一个把任务的参数，和执行选项与任务打包后的对象，可以直接调用和执行任务；<br>任务的作用是使得待执行的任务像参数一样便于传输，也便于对不同的任务工作流的操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建方法 1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> celery <span class="keyword">import</span> signature</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sig = signature(<span class="string">'tasks.add'</span>, args=(<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建方法 2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sig = add.s(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 签名的调用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sig.delay()  <span class="comment"># sig.apply_async() 同样可以调用</span></span><br><span class="line">&lt;AsyncResult: fb893496<span class="number">-27</span>f1<span class="number">-47</span>a3-a04c<span class="number">-8</span>bba1cdaced2&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不可变任务签名</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isig = signature(<span class="string">'tasks.add'</span>, args=(<span class="number">3</span>, <span class="number">4</span>), immutable=<span class="keyword">True</span>)  <span class="comment"># 不可变签名绑定的任务数据不可更改</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isig = add.si(<span class="number">3</span>, <span class="number">4</span>)  <span class="comment"># 不可变签名</span></span><br></pre></td></tr></table></figure>
<p>任务签名更像一个包含了任务参数的高阶函数。把具体任务的声明和调用分隔开来，便于任务的调度。</p>
<ul>
<li>原语与组合</li>
</ul>
<p>原语是把多个任务的签名组合起来。</p>
<p>1.Group<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> celery <span class="keyword">import</span> group</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = group(add.s(<span class="number">2</span>, <span class="number">2</span>), add.s(<span class="number">3</span>, <span class="number">3</span>), add.s(<span class="number">4</span>, <span class="number">4</span>))()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res.get(timeout=<span class="number">1</span>)  <span class="comment"># 设置等待超时时间</span></span><br><span class="line">[<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = group(add.s(i, i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>))()</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p><code>group</code>使多个任务并行执行，全部任务结束后，并把结果按照任务添加顺序返回。</p>
<p>2.Chain<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = chain(add.s(<span class="number">2</span>, <span class="number">2</span>), add.s(<span class="number">4</span>), add.s(<span class="number">8</span>))()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res.get()</span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure></p>
<p><code>chain</code>把多个任务串起来，按顺序执行；并把前一个任务的结果作为参数传递到下一个任务中。<br>最终返回最后一个任务的结果。</p>
<p>3.Chord</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 新增xsum任务</span><br><span class="line">@app.task</span><br><span class="line">def xsum(numbers):</span><br><span class="line">    return sum(numbers)</span><br></pre></td></tr></table></figure>
<p><code>chord</code>的作用就像是<code>group</code>再加一个回调函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from celery import chord</span><br><span class="line">from tasks import add, xsum</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; chord(add.s(i, i)</span><br><span class="line">          for i in xrange(100))(xsum.s()).get()</span><br><span class="line">9900</span><br></pre></td></tr></table></figure></p>
<p>4.Map, Starmap</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新增is_odd任务</span></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_odd</span><span class="params">(x)</span>:</span></span><br><span class="line">true<span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> tasks <span class="keyword">import</span> is_odd</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>is_odd.map(range(<span class="number">10</span>))</span><br><span class="line">[tasks.is_odd(x) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]  <span class="comment"># mao的作用很明显了，将每一项作为参数调用任务</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>is_odd.map(range(<span class="number">10</span>)).delay()  <span class="comment"># 只会向broker添加一个任务！</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>xsum.starmap([range(<span class="number">10</span>), range(<span class="number">100</span>)])</span><br><span class="line">[tasks.xsum(*x) <span class="keyword">for</span> x <span class="keyword">in</span> [range(<span class="number">0</span>, <span class="number">10</span>), range(<span class="number">0</span>, <span class="number">100</span>)]]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add.starmap([(<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>)])</span><br><span class="line">[tasks.add(*x) <span class="keyword">for</span> x <span class="keyword">in</span> [(<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>)]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add.starmap([(<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>)]).delay().get()</span><br><span class="line">[<span class="number">7</span>, <span class="number">11</span>]</span><br></pre></td></tr></table></figure>
<p><code>Map</code>的作用类似于<code>map</code>函数，依次对每一个参数执行任务函数；<br>不同的时，使用<code>Map</code>只会添加一个任务到队列中，并对单个任务反复执行的结果进行收集，效果类似于<code>Group</code>但是只在一个worker中执行；<br><code>Starmap</code>的作用也类似，只是会对参数多做一次拆包处理。</p>
<p>5.Chunk</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>add.chunks(zip(range(<span class="number">0</span>, <span class="number">10</span>), range(<span class="number">1</span>, <span class="number">11</span>)), <span class="number">5</span>)</span><br><span class="line">celery.chunks(task=tasks.add(), it=[(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">4</span>, <span class="number">5</span>), (<span class="number">5</span>, <span class="number">6</span>), (<span class="number">6</span>, <span class="number">7</span>), (<span class="number">7</span>, <span class="number">8</span>), (<span class="number">8</span>, <span class="number">9</span>), (<span class="number">9</span>, <span class="number">10</span>)], n=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add.chunks(zip(range(<span class="number">0</span>, <span class="number">10</span>), range(<span class="number">1</span>, <span class="number">11</span>)), <span class="number">5</span>).delay().get()</span><br><span class="line">[[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>], [<span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">17</span>, <span class="number">19</span>]]</span><br></pre></td></tr></table></figure>
<p><code>Chunks</code>的作用就是把大量的任务分块添加到任务队列，每个块的数据量n由第三个参数指定；<br>不足的数量单独算作一块。</p>
<p>此外删除的原语结构可以嵌套足够，灵活地定制的任务流。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_chord_error</span><span class="params">(request, exc, traceback)</span>:</span></span><br><span class="line">    print(<span class="string">'Task &#123;0!r&#125; raised error: &#123;1!r&#125;'</span>.format(request.id, exc))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过chain把group和错误处理任务链接起来； 由on_chord_error处理可能的错误</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = (group(add.s(i, i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)) |</span><br><span class="line"><span class="meta">... </span>     xsum.s().on_error(on_chord_error.s())).delay()</span><br></pre></td></tr></table></figure>
<h4 id="任务队列-task-queue"><a href="#任务队列-task-queue" class="headerlink" title="任务队列 (task queue)"></a>任务队列 (task queue)</h4><p><code>celery</code>所有未指明队列的任务都归属到默认的任务队列<code>celery</code>(在配置中可以修改默认的队列名)；<br>但这样把所有的任务加到同一个队列中容易出问题，如较慢的任务可能阻塞队列。<br>更好的做法是按照任务的类别，区分不同的任务队列，并绑定到不同的worker;</p>
<ol>
<li>路由任务到指定的队列</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法 1： 在配置中指定</span></span><br><span class="line">task_routes = &#123;</span><br><span class="line">        <span class="string">'tasks.slow_task'</span>: &#123;</span><br><span class="line">            <span class="string">'queue'</span>: <span class="string">'slow'</span>,</span><br><span class="line">            <span class="string">'routing_key'</span>: <span class="string">'slow'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法 2: 定义任务时指定队列</span></span><br><span class="line"><span class="meta">@app.task(queue='slow')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">slow_task</span><span class="params">(*args)</span>:</span></span><br><span class="line">true<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法 3：任务调用时指明队列或路由key</span></span><br><span class="line">task_args = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">slow_task.apply_async(args=task_args, queue=<span class="string">"slow"</span>)</span><br></pre></td></tr></table></figure>
<p>上述三者的优先级分别为： 3 &gt; 2 &gt; 1，较高优先级可以覆盖较低优先级的配置;</p>
<ol start="2">
<li>绑定队列到<code>worker</code></li>
</ol>
<p>不指定队列时启动worker, 其实绑定到默认的队列<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">celery -A tasks worker -l info</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">celery -A tasks worker -l info -Q celery  <span class="comment"># 与上一句等价, 只执行celery队列中的任务</span></span><br><span class="line"></span><br><span class="line">celery -A tasks worker -l info -Q slow  <span class="comment"># 只执行slow队列中添加的任务</span></span><br><span class="line"></span><br><span class="line">celery -A tasks worker -l info -Q slow,celery  <span class="comment"># 可以执行两个渠道的任务</span></span><br></pre></td></tr></table></figure></p>
<p>需要说明的时，当一个worker处理多个队列的任务时，未指定队列优先级时，获取任务的顺序是随机的。<br><code>rabbitmq</code>作为broker时，支持队列配置不同的优先级。</p>
<p>此外, <code>apply_async</code>也支持<code>priority</code>参数，可以为同一个队列中的任务指定不同的执行优先级。</p>
<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>在前一篇文章里，我们知道了<code>celery</code>的基本架构和基本使用。<br>而本篇，我们学会了使用不同的任务原语来组织任务，实现更灵活的任务流。</p>
<p>此外，我们知道了<code>celery</code>是按照任务队列来向worker分发任务的，而多种不同的任务放在同一个队列中是不明智的决定。<br>根据任务的需要可以指定不同的任务队列，开启多个worker分别取执行不同类别的任务，减少任务被阻塞的可能。<br>具体的部署方案，可以根据实际的需要来设计，但是一定把不同的任务分到不同的队列，在下一篇里我会分享因队列设置而遇到的问题。</p>
<p>在下一篇里，我将分享一些我收集到的<code>celery</code>最佳实践和一些可能遇到的实际问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目中用到了&lt;code&gt;celery&lt;/code&gt;，最近踩了一些坑。花点时间整理下有关&lt;code&gt;celery&lt;/code&gt;的知识。&lt;br&gt;本文是&lt;code&gt;celery&lt;/code&gt;笔记的第二篇，主要是&lt;code&gt;celery&lt;/code&gt;的常见高级用法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="-- python -- celery" scheme="https://yabzhang.github.io/tags/python-celery/"/>
    
  </entry>
  
  <entry>
    <title>celery 笔记(1)</title>
    <link href="https://yabzhang.github.io/2018/08/10/celery-%E7%AC%94%E8%AE%B0-1/"/>
    <id>https://yabzhang.github.io/2018/08/10/celery-笔记-1/</id>
    <published>2018-08-09T16:08:45.000Z</published>
    <updated>2018-08-09T16:17:10.419Z</updated>
    
    <content type="html"><![CDATA[<p>项目中用到了<code>celery</code>，最近踩了一些坑。花点时间整理下有关<code>celery</code>的知识。<br>本文是<code>celery</code>笔记的第一篇，主要了解下<code>celery</code>中的基本概念和基本使用。</p>
<a id="more"></a>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote><p>Celery is an asynchrounous task queue based on distributed message passing.</p>
</blockquote>
<p>简单来说，<code>celery</code> 是一个任务队列，支持任务的异步执行，支持一定的任务调度功能，并且也可以部署多个分布式工作节点来提高任务的执行效率。</p>
<p><code>celery</code> 有很多的使用场景，但共同点可以简单概括为，就是把一些比较消耗资源的任务分发到其他的任务节点去执行，以提高整个系统的工作效率。</p>
<p>例如这样的场景：某web服务，用户的一个请求触发了一个邮件发送。这个时候我们可以吧这个耗时的邮件任务添加到 <code>celery</code> 的任务队列中去执行；而用户的响应就可以很快滴返回，而不用去等待邮件发送的结束。而且，我们也可以很方便地查看 <code>celery</code> 中的任务的执行进度和结果。</p>
<p><br><br>放一张 <code>celery</code> 架构图:<br><img src="/2018/08/10/celery-笔记-1/celery_structure.png" title="local file"></p>
<p>下边介绍几个概念：</p>
<p>客户端(client): 添加 <code>celery</code> 任务的程序，可能为 web 服务, 或者添加任务的脚本等。</p>
<p>工作节点(worker): 任务的实际执行者，一般是<code>celery</code>的服务。</p>
<p>Broker: 消息传输的中间设施；在 <code>celery</code> 的设计结构中，客户端添加任务到队列中，消息中转者(<code>broker</code>)把任务数据或者消息传递给工作节点; <code>celery</code> 可选的 Broker 有很多，如: <code>RabbitMQ</code>, <code>Redis</code>, 等。<code>RabbitMQ</code>提供更多高级特性，相比于<code>Redis</code>也更稳定（redis掉电丢数据）。</p>
<p>任务结果存储(Task Result Storage)，又叫 backend。主要用于存储任务的状态、结果和异常栈等信息。可选项很多：SQLAlchemy/Django ORM, Memcached, Redis, RPC (RabbitMQ/AMQP) 等。但对于任务执行这个并不是必须的。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ul>
<li>安装</li>
</ul>
<p><a href="https://github.com/celery/celery/" target="_blank" rel="noopener"><code>github</code>项目的首页</a>列出了挺多的信息，如运行环境，各种依赖的安装等等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install -U celery</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"><span class="comment"># pip install celery[librabbitmq,redis,auth,msgpack]  # 安装依赖</span></span><br></pre></td></tr></table></figure>
<ul>
<li>定义任务</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tasks.py</span></span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line">app = Celery(</span><br><span class="line">    __name__,</span><br><span class="line">    broker=<span class="string">"redis://localhost:6379/0"</span>, </span><br><span class="line">    backend=<span class="string">"redis://localhost:6379/0"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure>
<p>在<code>tasks.py</code>中的定义的<code>add</code>任务；</p>
<ul>
<li>启动工作节点<code>worker</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> worker shell</span><br><span class="line">celery worker -A tasks -l info</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(myapp) ~/Projects/demo celery -A tasks worker -l info</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">celery@HackEngine.local v4.2.1 (windowlicker)</span><br><span class="line"></span><br><span class="line">Darwin-17.7.0-x86_64-i386-64bit 2018-08-09 23:20:41</span><br><span class="line"></span><br><span class="line">[config]</span><br><span class="line">.&gt; app:         tasks:0x10d60c400</span><br><span class="line">.&gt; transport:   redis://localhost:6379/0</span><br><span class="line">.&gt; results:     redis://localhost:6379/1</span><br><span class="line">.&gt; concurrency: 8 (prefork)</span><br><span class="line">.&gt; task events: OFF (enable -E to monitor tasks in this worker)</span><br><span class="line"></span><br><span class="line">[queues]</span><br><span class="line">.&gt; celery           exchange=celery(direct) key=celery</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[tasks]</span><br><span class="line">  . tasks.add</span><br></pre></td></tr></table></figure>
<p>将工作目录切换到任务模块，然后使用上述命令来启动一个<code>worker</code>；<br>然后终端会打印出配置信息，在<code>[tasks]</code>这里可看到我们已注册的任务。</p>
<ul>
<li>执行任务</li>
</ul>
<p>在任务模块新打开一个python的交互环境， 以<code>#python shell</code>标识。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python shell</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> tasks <span class="keyword">import</span> add</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add.delay(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&lt;AsyncResult: <span class="number">9</span>c9abc10-db1c<span class="number">-4071</span>-a762<span class="number">-3e23</span>fd54e5a5&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_.result</span><br><span class="line"><span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = add.apply_async(args=(<span class="number">3</span>, <span class="number">4</span>))  <span class="comment"># 另一种任务调用方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add(<span class="number">3</span>, <span class="number">4</span>)  <span class="comment"># 直接调用会像普通函数一样执行</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add.apply_async(args=(<span class="number">3</span>, <span class="number">4</span>), countdown=<span class="number">10</span>)  <span class="comment"># 添加任务，并延时10s执行</span></span><br></pre></td></tr></table></figure>
<p>上述过程是在python环境中添加了一个<code>add</code>任务，然后我们得到了一个<code>AsyncResult</code>对象；<br>任务的结果我们可以通过这个对象得到;</p>
<p>我们的工作节点<code>worker</code>会显示接收到一个任务，并且给出了任务的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># worker shell</span><br><span class="line">[2018-08-09 23:26:09,309: INFO/MainProcess] Received task: tasks.add[9c9abc10-db1c-4071-a762-3e23fd54e5a5]</span><br><span class="line">[2018-08-09 23:26:09,325: INFO/ForkPoolWorker-8] Task tasks.add[9c9abc10-db1c-4071-a762-3e23fd54e5a5] succeeded in 0.011711072000025524s: 7</span><br></pre></td></tr></table></figure></p>
<p>整个过程就是: 通过<code>#python shell</code>客户端添加了一个任务到broker中。<br>然后我们的worker从broker中获取到任务数据并异步地执行；<br>执行完毕后worker把结果存放在backend中；<br>随后客户端又通过<code>AsyncResult</code>对象从backend中获取到任务的结果。</p>
<p>就像上边这样，我们可以把发送邮件、大文件操作、或者音视频转码等类似的操作都放在celery任务中来做。</p>
<h3 id="写在结尾"><a href="#写在结尾" class="headerlink" title="写在结尾"></a>写在结尾</h3><p>前边我们简单了解了<code>celery</code>的架构，知道了<code>client</code>, <code>broker</code>, <code>worker</code>, <code>backend</code>具体的作用；<br>也通过定义了一个简单的<code>add</code>任务来了解了<code>celery</code>的使用和任务的执行过程;</p>
<p>后边还有一些高级的用法，我们留到下一篇来讲。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目中用到了&lt;code&gt;celery&lt;/code&gt;，最近踩了一些坑。花点时间整理下有关&lt;code&gt;celery&lt;/code&gt;的知识。&lt;br&gt;本文是&lt;code&gt;celery&lt;/code&gt;笔记的第一篇，主要了解下&lt;code&gt;celery&lt;/code&gt;中的基本概念和基本使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="-- python -- celery" scheme="https://yabzhang.github.io/tags/python-celery/"/>
    
  </entry>
  
  <entry>
    <title>mac系统中vim-taglist的配置</title>
    <link href="https://yabzhang.github.io/2018/08/06/mac%E7%B3%BB%E7%BB%9F%E4%B8%ADvim-taglist%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>https://yabzhang.github.io/2018/08/06/mac系统中vim-taglist的配置/</id>
    <published>2018-08-05T16:20:37.000Z</published>
    <updated>2018-08-05T16:46:21.742Z</updated>
    
    <content type="html"><![CDATA[<p><code>taglist</code>, <code>nerdtree</code>, 语法检查等是 <code>vim</code> 最常用的插件。今天在mac系统下配置的 <code>taglist.vim</code> 插件的时候遇到一点坑，特此记录备忘。<br><a id="more"></a></p>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>按照 <a href="http://vim-taglist.sourceforge.net/installation.html" target="_blank" rel="noopener"><code>taglist 官网</code></a> 的描述下载和安装插件后，插件并没有生效。<br><code>which ctags</code> 命令，确认了依赖的 <code>ctags</code> 已经安装。没有头绪。</p>
<p>google 了一下，原来 <code>mac osx</code> 系统自带的 <code>ctags</code> 并不是 <code>taglist</code> 插件依赖的那个。<br>问题确认了，那么安装依赖的软件就好了。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li><p>重装<code>ctags</code></p>
<p> 这里可以去下载源码编译；更简单的方法当然是 <code>brew install ctags</code>;</p>
<p> 我这一步可以看到安装的路径：<code>/usr/local/Cellar/ctags/5.8_1/bin/ctags</code></p>
</li>
<li><p>调整命令</p>
<p> 更新<code>taglist.vim</code>插件的配置，采用新安装的ctags命令来运行插件;<br> 在<code>.vimrc</code>（或位于其他地方的配置文件）中添加：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let g:Tlist_Ctags_Cmd=&apos;$ctags_executable&apos;</span><br><span class="line"></span><br><span class="line"># 比如，我的 `brew install ctags` 安装在 /usr/local/Cellar/ctags/5.8_1/bin/ctags</span><br><span class="line"></span><br><span class="line">let g:Tlist_Ctags_Cmd=&apos;/usr/local/Cellar/ctags/5.8_1/bin/ctags&apos;</span><br></pre></td></tr></table></figure>
<p> 之后在 <code>vim</code> 中尝试下 <code>:TlistToggle</code>，发现函数目录就出来了。</p>
<p> 最后就是添加快捷键(这里配置为<code>F2</code>)：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">noremap &lt;F2&gt; :TlistToggle&lt;CR&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;taglist&lt;/code&gt;, &lt;code&gt;nerdtree&lt;/code&gt;, 语法检查等是 &lt;code&gt;vim&lt;/code&gt; 最常用的插件。今天在mac系统下配置的 &lt;code&gt;taglist.vim&lt;/code&gt; 插件的时候遇到一点坑，特此记录备忘。&lt;br&gt;
    
    </summary>
    
    
      <category term="-- mac -- vim -- taglist" scheme="https://yabzhang.github.io/tags/mac-vim-taglist/"/>
    
  </entry>
  
  <entry>
    <title>pidfile的用途</title>
    <link href="https://yabzhang.github.io/2018/06/17/pidfile%E7%9A%84%E7%94%A8%E9%80%94/"/>
    <id>https://yabzhang.github.io/2018/06/17/pidfile的用途/</id>
    <published>2018-06-17T06:54:29.000Z</published>
    <updated>2018-08-02T17:38:33.846Z</updated>
    
    <content type="html"><![CDATA[<p>在<code>linux</code>系统中经常可以看到很多<code>pid</code>文件，如: <code>/var/run</code>目录下。<br>了解了下这类文件用途，特此记录。</p>
<a id="more"></a>
<h3 id="pidfile"><a href="#pidfile" class="headerlink" title="pidfile"></a>pidfile</h3><p><code>linux</code>下的很多程序会在运行时创建<code>.pid</code>后缀的文件，文件的内容只有一行，程序进程号。<br><code>pidfile</code>一般用于检测某程序是否已经运行，和获取某运行中程序的进程号<code>pid</code>。</p>
<p>检测的逻辑大致是，在程序执行时尝试获取对应pid文件互斥访问权限；<br>若获取成功，则程序继续执行并写入进程号；若获取失败，则退出执行；<br>在程序执行完毕后需要对<code>pidfile</code>进行  清理工作;</p>
<p>看到有些例子中，互斥访问的设计可能会埋坑，比如使用文件是否存在来判断并不准确;<br>Ｃ语言中的 <a href="https://linux.die.net/man/3/pidfile" target="_blank" rel="noopener">pidfile</a> 使用互斥锁的方式来保证<code>pidfile</code>的互斥访问, 会是更好的方案。</p>
<p>尽管如此，<code>pidfile</code>还是有不少问题。<br>就像<code>Supervisor</code>的文档中说的,</p>
<blockquote><p>Pidfiles often lie.</p>
<footer><strong>Supervisor</strong><cite><a href="http://supervisord.org/introduction.html" target="_blank" rel="noopener">supervisord.org/introduction.html</a></cite></footer></blockquote>
<h3 id="pidfile的问题"><a href="#pidfile的问题" class="headerlink" title="pidfile的问题"></a>pidfile的问题</h3><p>有关<code>pidfile</code>的问题，搬运个不错的回答。<a href="https://superuser.com/questions/589698/monitoring-a-process" target="_blank" rel="noopener">monitoring-a-process</a></p>
<ul>
<li><code>pid</code>的数量是有限的，系统复用会用进程号</li>
</ul>
<p>所以有时候<code>pidfile</code>中进程号对应进程运行得可能是其他的程序。<br>由进程号获取的程序状态就不太可信了。冗余的操作是再确定程序启动时间。<br>但事情看起来变得麻烦了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 获取当前系统最大的pid</span><br><span class="line">$ cat /proc/sys/kernel/pid_max</span><br></pre></td></tr></table></figure>
<p>32位系统上限为<code>32768</code>, 64位系统上限为<code>2^22</code>，大约四百多万。<br>更详细的回答参考这篇文章 <a href="https://unix.stackexchange.com/questions/16883/what-is-the-maximum-value-of-the-process-id" target="_blank" rel="noopener">what-is-the-maximum-value-of-the-process-id</a></p>
<ul>
<li>可能的<code>pidfile</code>清理问题</li>
</ul>
<p>通常配置了自启动的脚本，其<code>pidfile</code>并不是脚本创建的。<br>而是自启动服务提供者代为创建，比如: <code>rc</code>, <code>systemd</code>等。<br>这样可能发生<code>pidfile</code>文件的管理和清理等问题。</p>
<h3 id="更好的服务进程管理方式"><a href="#更好的服务进程管理方式" class="headerlink" title="更好的服务进程管理方式"></a>更好的服务进程管理方式</h3><p>自己的轻量级服务或者脚本推荐使用<code>Supervisor</code>。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>打印上一条命令的进程号</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 打印上一条命令的进程号</span><br><span class="line">echo &amp;!</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> e.g</span><br><span class="line">echo '123' &amp; echo &amp;!</span><br><span class="line">which python &amp; echo &amp;!</span><br></pre></td></tr></table></figure>
<ul>
<li>杀死指定程序</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 杀死nginx进程</span><br><span class="line">kill -HUP `cat /path/to/nginx.pid`</span><br></pre></td></tr></table></figure>
<blockquote><p>不要killall，因为一般程序可能会起多个进程，但是只有主进程会接受信号。子进程接受这些信号可能因为没有处理而出错</p>
<footer><strong>叔度,一楼评论</strong><cite><a href="https://www.zhihu.com/question/20289583" target="_blank" rel="noopener">www.zhihu.com/question/20289583</a></cite></footer></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;code&gt;linux&lt;/code&gt;系统中经常可以看到很多&lt;code&gt;pid&lt;/code&gt;文件，如: &lt;code&gt;/var/run&lt;/code&gt;目录下。&lt;br&gt;了解了下这类文件用途，特此记录。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ssh免密设置</title>
    <link href="https://yabzhang.github.io/2018/06/16/%E5%BF%AB%E6%8D%B7ssh%E5%85%8D%E5%AF%86%E8%AE%BE%E7%BD%AE/"/>
    <id>https://yabzhang.github.io/2018/06/16/快捷ssh免密设置/</id>
    <published>2018-06-16T15:05:47.000Z</published>
    <updated>2018-08-02T17:38:33.847Z</updated>
    
    <content type="html"><![CDATA[<p>常用的 <code>ssh</code> 或者 <code>scp</code> 命令一般都会选择配置免密码登录，不然每次输入密码会挺痛苦的。<br>但现在有了更方便的操作方法，一个方便的命令 <strong><code>ssh-copy-id</code></strong>，特此记录备忘。</p>
<a id="more"></a>
<p>常规是手动将公钥拷贝到目标主机 <code>~/.ssh/authorized_keys</code>，再对文件目录访问权限进行配置。<br>相比之下，一句<code>ssh-copy-id</code>命令可以大大节约配置的时间。下面来看下具体操作流程。</p>
<h3 id="设置-ssh-免密登录"><a href="#设置-ssh-免密登录" class="headerlink" title="设置 ssh 免密登录"></a>设置 ssh 免密登录</h3><h4 id="1-在本地生成-ssh-公钥和秘钥"><a href="#1-在本地生成-ssh-公钥和秘钥" class="headerlink" title="1. 在本地生成　ssh　公钥和秘钥"></a>1. 在本地生成　ssh　公钥和秘钥</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#　生成公钥密钥对</span><br><span class="line"></span><br><span class="line">ssh-keygen -b 4096 -t rsa</span><br></pre></td></tr></table></figure>
<p>这里指定的是 <code>rsa</code>　加密的类型，长度为4096位。<br>生成的秘钥就存储在 <code>~/.ssh/id_rsa</code> 中，公钥在 <code>~/.ssh/id_rsa.pub</code> 中。</p>
<h4 id="2-将公钥上传到目标主机"><a href="#2-将公钥上传到目标主机" class="headerlink" title="2. 将公钥上传到目标主机"></a>2. 将公钥上传到目标主机</h4><p>这一步就可以使用 <code>ssh-copy-id</code> 来完成, 而这个命令包含在<strong><code>openssh-client</code></strong>软件包中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 先安装`openssh-client`软件包</span><br><span class="line">sudo apt-get install openssh-client</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 确认ssh-copy-id可用</span><br><span class="line">which ssh-copy-id</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 添加秘钥到目标主机</span><br><span class="line">ssh-copy-id username@remote-server</span><br></pre></td></tr></table></figure>
<p>其中 username 为目标主机的用户名, remote-server 为目标主机的host或者ip；<br>本次登录需要输入密码，登录后<code>ssh-copy-id</code>命令就自动完成了其他的免密设置。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://www.linuxdashen.com/ssh-key%EF%BC%9A%E4%B8%A4%E4%B8%AA%E7%AE%80%E5%8D%95%E6%AD%A5%E9%AA%A4%E5%AE%9E%E7%8E%B0ssh%E6%97%A0%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95" target="_blank" rel="noopener">ssh-key：两个简单步骤实现ssh无密码登录</a>
</li>
<li><a href="http://manpages.ubuntu.com/manpages/precise/man1/ssh-copy-id.1.html" target="_blank" rel="noopener">Ubuntu anpages ssh-copy-id</a>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常用的 &lt;code&gt;ssh&lt;/code&gt; 或者 &lt;code&gt;scp&lt;/code&gt; 命令一般都会选择配置免密码登录，不然每次输入密码会挺痛苦的。&lt;br&gt;但现在有了更方便的操作方法，一个方便的命令 &lt;strong&gt;&lt;code&gt;ssh-copy-id&lt;/code&gt;&lt;/strong&gt;，特此记录备忘。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://yabzhang.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>review-基本算法</title>
    <link href="https://yabzhang.github.io/2017/08/05/review-%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/"/>
    <id>https://yabzhang.github.io/2017/08/05/review-基本算法/</id>
    <published>2017-08-05T13:06:23.000Z</published>
    <updated>2018-08-02T17:38:33.846Z</updated>
    
    <content type="html"><![CDATA[<p>复习基础算法（基本的排序和查找算法）。<br><a id="more"></a></p>
<h3 id="basic-algo"><a href="#basic-algo" class="headerlink" title="basic algo."></a>basic algo.</h3><p>谈到基本算法肯定就是排序和查找了，那就具体来看下这些基本的排序和查找算法；</p>
<h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>基本的排序算法包括：<br>１. 冒泡排序<br>２. 选择排序<br>３. 插入排序<br>４. 希尔排序<br>５. 归并排序<br>６. 快排</p>
<p>排序算法分为稳定和非稳定两类。<br>稳定排序算法的复杂度不会因序列有所改变；<br>而非稳定排序的算法复杂度会因特定的原因导致算法执行效率下降，复杂度增加；<br>比较型排序算法的Big-O复杂度一般不会低于<code>O(nlogn)</code>；</p>
<ul>
<li>冒泡排序</li>
</ul>
<p>冒泡排序是稳定排序，复杂度<code>O(n^2)</code>;<br>排序时，依次遍历序列，两两比较。若后者大于前者则交换顺序，否则继续下一组比较；<br>当一轮遍历完成后，最大的元素就会被交换到序列的最后一位，整个过程就像冒泡一样；<br>之后继续进行下一轮遍历，比较和交换位置。具体过程同上；<br>若某一次遍历完成后，并没有元素需要交换位置，那么排序就完成了；<br>遍历过程，最少一次，最多n次;</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(seq)</span>:</span></span><br><span class="line">    done = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(seq) - <span class="number">1</span>):</span><br><span class="line">        done = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(seq) - i):</span><br><span class="line">            <span class="keyword">if</span> seq[j] &lt; seq[j - <span class="number">1</span>]:</span><br><span class="line">                seq[j], seq[j - <span class="number">1</span>] = seq[j - <span class="number">1</span>], seq[j]</span><br><span class="line">                done = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> done:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> seq</span><br></pre></td></tr></table></figure>
<ul>
<li>选择排序</li>
</ul>
<p>选择排序是稳定排序,复杂度<code>O(n^2)</code>;<br>选择排序就像字面意思一样，每次从剩余列表中选择出最小的元素排在前面；<br>具体的过程就像小学做操的时候，每次排队，老师都找到最矮的排在前面，全部过程结束后，就排好了队；<br>这里在排序时，也是每次都找到剩余部分最小的元素，然后将最小的元素与其应该在的位置上的元素交换即可；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span><span class="params">(seq)</span>:</span></span><br><span class="line">    smallest = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(seq) - <span class="number">1</span>):</span><br><span class="line">        smallest = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(seq)):</span><br><span class="line">            <span class="keyword">if</span> seq[j] &lt; seq[smallest]:</span><br><span class="line">                smallest = j</span><br><span class="line">        seq[i], seq[smallest] = seq[smallest], seq[i]</span><br><span class="line">    <span class="keyword">return</span> seq</span><br></pre></td></tr></table></figure>
<ul>
<li>插入排序</li>
</ul>
<p>插入排序是稳定排序，复杂度<code>O(n^2)</code>;<br>插入排序时先分出一部分序列是拍好序的，然后每次从未排序的部分取出元素插入到已排序的部分中应该在的位置；<br>一直持续这个过程，直到所有的未排序全部都插入到已排序列中，排序完成；<br>在代码实现中，选择以交换的方式来移动位置；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(seq)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(seq)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> seq[j] &lt; seq[j - <span class="number">1</span>]:</span><br><span class="line">                seq[j], seq[j - <span class="number">1</span>] = seq[j - <span class="number">1</span>], seq[j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> seq</span><br></pre></td></tr></table></figure>
<ul>
<li>希尔排序</li>
</ul>
<p>希尔排序是插入排序的升级版，目的是为了减少排序时的移位操作；<br>具体的做法是先把待排序列分成一定间隔的元素组成的子序列，使用插入排序完成子序列的排序；<br>然后进一步减少分组数目，重新分配子序列，再次重复上述过程；<br>最后分组数目减少为１时，就与插入排序相同了；但移位操作可以有效减少；<br>最坏复杂度为<code>O(n^2)</code>；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(seq)</span></span></span><br><span class="line">    sub_cnt = len(seq) // 2</span><br><span class="line">    <span class="keyword">while</span> sub_cnt &gt; <span class="number">0</span>:  <span class="comment"># 最小为１个分组</span></span><br><span class="line">        <span class="keyword">for</span> start <span class="keyword">in</span> range(sub_cnt):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start + sub_cnt, len(seq), sub_cnt):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(i, start, -sub_cnt):</span><br><span class="line">                    <span class="keyword">if</span> seq[j] &lt; seq[j - sub_cnt]:</span><br><span class="line">                        seq[j], sq[j - sub_cnt] = seq[sub_cnt], seq[j]</span><br><span class="line">        sub_cnt = sub_cnt // <span class="number">2</span>  <span class="comment"># 减少分组</span></span><br><span class="line">    <span class="keyword">return</span> sub_cnt</span><br></pre></td></tr></table></figure>
<ul>
<li>归并排序</li>
</ul>
<p>归并排序使用了分治的思想，把问题分解为子问题，然后递归这个过程。<br>直到最终的子问题容易解决，然后把结果合并；最后通过合并子问题的结果，得到原有问题的解答；<br>归并排序是稳定排序，算法复杂度为<code>O(nlogn)</code>,需要额外的存储空间<code>O(n)</code>；</p>
<p>排序过程，先选择一个基准元素，与基准元素比较把列表分为两自列表：小于基准元素和大于等于基准元素。<br>之后对两自列表重复递归上述过程；最后可以得到长度为１子列表，可以认为这样的列表是已排序的；<br>然后把排好序的列表收集起来，最终得到排好序的列表；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(seq)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(seq) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> seq</span><br><span class="line"></span><br><span class="line">    mid = len(seq) // <span class="number">2</span></span><br><span class="line">    left = merge_sort(seq[:mid])</span><br><span class="line">    right = merge_sort(seq[mid:])</span><br><span class="line"></span><br><span class="line">    cnt, m, n = [<span class="number">0</span>] * <span class="number">3</span></span><br><span class="line">    <span class="keyword">while</span> m &lt; len(left) <span class="keyword">and</span> n &lt; len(right):</span><br><span class="line">        <span class="keyword">if</span> left[m] &lt;= right[n]:</span><br><span class="line">            seq[cnt] = left[m]</span><br><span class="line">            m += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            seq[cnt] = right[n]</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> m &lt; len(left):</span><br><span class="line">        <span class="keyword">while</span> m &lt; len(left) <span class="keyword">and</span> cnt &lt; len(seq):</span><br><span class="line">            seq[cnt] = left[m]</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            m += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> n &lt; len(right):</span><br><span class="line">        <span class="keyword">while</span> n &lt; len(right) <span class="keyword">and</span> cnt &lt; len(seq):</span><br><span class="line">            seq[cnt] = right[n]</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> seq</span><br></pre></td></tr></table></figure>
<ul>
<li>快排</li>
</ul>
<p>快排是非稳定排序，一般情况时算法的复杂度为<code>O(n)</code>；<br>但若是在最坏情况下，算法复杂度会退化到<code>O(n^2)</code>；<br>快排的过程，每一次迭代会从序列中选出一个基准元素，然后以此基准把序列分为较小(左)和较大(右)的两部分；<br>然后再分别对这两部分重复此过程；最后得到排好的序列；</p>
<p>最坏情况出现在每次选择基准元素均选中了最小或最大的元素，这样序列就不能成功地分为两部分；<br>复杂度就会退化为<code>O(n^2)</code>的复杂度；所以一般选择使用随机数来选择基准元素，尽量避免最坏情况的出现；</p>
<p>采用原地快排可以节省额外空间的使用；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(seq, start, end)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> end - start &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    base = random.randint(start, end)</span><br><span class="line">    seq[start], seq[base] = seq[base], seq[start]</span><br><span class="line"></span><br><span class="line">    pivot, cnt = start, start</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(start + <span class="number">1</span>, end + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> seq[i] &lt; seq[pivot]:</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            seq[cnt] = seq[i]</span><br><span class="line">    seq[pivot], seq[cnt] = seq[cnt], seq[pivot]</span><br><span class="line"></span><br><span class="line">    quick_sort(seq, start, cnt - <span class="number">1</span>)</span><br><span class="line">    quick_sort(seq, cnt + <span class="number">1</span>, end)</span><br><span class="line">    <span class="keyword">return</span> seq</span><br></pre></td></tr></table></figure>
<h4 id="search"><a href="#search" class="headerlink" title="search"></a>search</h4><p>基本的查找算法：顺序查找和二分查找；</p>
<ul>
<li>顺序查找</li>
</ul>
<p>顾名思义，就是按照顺序查找；复杂度<code>O(n)</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sequential_search</span><span class="params">(seq, item)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(seq)):</span><br><span class="line">        <span class="keyword">if</span> seq[i] == item:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>二分查找</li>
</ul>
<p>二分查找，算法复杂度为<code>O(logn)</code>；<br>要求序列是有序的；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bin_search</span><span class="params">(seq, item)</span>:</span></span><br><span class="line">    start, end = <span class="number">0</span>, len(seq) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> seq[mid] &gt; item:</span><br><span class="line">            end = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> seq[mid] &lt; item:</span><br><span class="line">            start = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="the-end"><a href="#the-end" class="headerlink" title="the end"></a>the end</h3><p>基本算法：</p>
<p>６种基本排序算法；<br>比较型排序算法最快不会小于<code>O(nlogn)</code>；</p>
<p>两种基本查找算法，其中二分查找要求序列有序。</p>
]]></content>
    
    <summary type="html">
    
      基础算法
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>review-基本数据结构</title>
    <link href="https://yabzhang.github.io/2017/08/05/review%EF%BC%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://yabzhang.github.io/2017/08/05/review－基本数据结构/</id>
    <published>2017-08-05T06:23:49.000Z</published>
    <updated>2018-08-02T17:38:33.847Z</updated>
    
    <content type="html"><![CDATA[<p>复习基础的数据结构（栈，队列，链表）。<br><a id="more"></a></p>
<h3 id="basic-data-structure"><a href="#basic-data-structure" class="headerlink" title="basic data structure"></a>basic data structure</h3><ul>
<li>Stack</li>
</ul>
<p>栈(Stack)，是一种支持后进先出(LIFO)的基本数据结构，可以使用数组或者链表实现；<br>支持的基本操作包括：<code>push</code>, <code>pop</code>, <code>size</code>, <code>is_empty</code>, <code>peek</code>;</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回元素数量"""</span></span><br><span class="line">        <span class="keyword">return</span> len(self.items)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""判断当前栈中是否为空"""</span></span><br><span class="line">        <span class="keyword">return</span> self.size() == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""向栈中压入元素"""</span></span><br><span class="line">        self.items.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""从栈中弹出元素，若为空栈则抛出ValueError异常"""</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Empty Stack'</span>)</span><br><span class="line">        <span class="keyword">return</span> self.items.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回栈顶元素，并不弹出，若为空栈则抛出ValueError异常"""</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Empty Stack'</span>)</span><br><span class="line">        <span class="keyword">return</span> self.items[<span class="number">-1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>栈结构的后入先出的特性有很多用途，如程序函数调用时就使用栈结构来保存现场，表达式句法分析时也会用到栈。</p>
<ul>
<li>Queue</li>
</ul>
<p>队列(queue)，是支持先进先出(FIFO)的基本数据结构，同样可以使用数组或者链表实现；<br>支持的基本操作包括：<code>enqueue</code>, <code>dequeue</code>, <code>size</code>, <code>is_empty</code>;</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回队列中元素数量"""</span></span><br><span class="line">        <span class="keyword">return</span> len(self.items)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""判断队列是否为空"""</span></span><br><span class="line">        <span class="keyword">return</span> self.size() == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""向队列添加一个元素"""</span></span><br><span class="line">        self.items.insert(<span class="number">0</span>, item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""从队列返回一个元素，若为空队列则抛出ValueError异常"""</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Empty Queue'</span>)</span><br><span class="line">        <span class="keyword">return</span> self.items.pop()</span><br></pre></td></tr></table></figure>
<p>队列结构有很多的衍生结构，如双端队列，优先级队列等。<br>队列结构可以保证元素按照入队列的顺序出队列，在实际使用中，也多用于实现有顺序要求的任务或消息流等；</p>
<ul>
<li>Linked List</li>
</ul>
<p>链表(Linked List), 是使用的最广泛的数据结构。<br>链表，数组或Python中的列表都是线性数据结构，但数组或列表元素在内存中位置是连续的，而链表元素间是通过指针或者索引联系起来的，而且只有相邻的元素间才会有联系；<br>这就意味着，对于数组或者列表，只要知道了某元素的索引和起始的位置可以通过内存偏移量访问到该元素，而对于链表只能通过相邻的元素来访问，对于随机访问只能从头遍历来寻找到指定元素；</p>
<p>对比链表与数组，数组在索引方面更有优势，适合于读操作较多的场景；而链表在创建和删除新元素方面没有存储方面的限制，更适合大量写操作的场景；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""链表节点元素类"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data, next=None)</span>:</span></span><br><span class="line">        self._data = data</span><br><span class="line">        self._next = next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""获取节点数据"""</span></span><br><span class="line">        <span class="keyword">return</span> self._data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""获取下一个节点"""</span></span><br><span class="line">        <span class="keyword">return</span> self._next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_data</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        <span class="string">"""设置节点数据"""</span></span><br><span class="line">        self._data = val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_next</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        ”“”设置节点下一个指向元素<span class="string">"""</span></span><br><span class="line"><span class="string">        self._next = node</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class SingleLinkedList(object):</span></span><br><span class="line"><span class="string">    """</span>单链表<span class="string">"""</span></span><br><span class="line"><span class="string">    def __init__(self):</span></span><br><span class="line"><span class="string">        self.head = None</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def is_empty(self):</span></span><br><span class="line"><span class="string">        ”“”判断是否为空"""</span></span><br><span class="line">        <span class="keyword">return</span> self.head == <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""增加新节点"""</span></span><br><span class="line">        tmp_node = Node(item)</span><br><span class="line">        tmp_node.set_next(self.head)</span><br><span class="line">        self.head = tmp_node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回链表节点数"""</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            cur = cur.get_next()</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""在链表中搜索指定数据的节点"""</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        found = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.get_data() == item:</span><br><span class="line">                <span class="keyword">return</span> cur</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.get_next()</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""删除链表中指定数据的节点"""</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        prev = <span class="keyword">None</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.get_data() == item:</span><br><span class="line">                <span class="keyword">if</span> prev <span class="keyword">is</span> <span class="keyword">None</span>:  <span class="comment"># head match</span></span><br><span class="line">                    self.set_head(cur.get_next())</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    prev.set_next(cur.get_next())</span><br><span class="line">                    prev = cur</span><br><span class="line">                cur = cur.get_next()</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev = cur</span><br><span class="line">                cur = cur.get_next()</span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>
<p>链表是使用的最广泛的数据结构之一，相关的话题和衍生的结构甚至不是一两篇文章可以讲得清的。<br>数据结构和算法是基本功，而链表更是数据结构中最基本的部分，需要投入时间和精力进行足够地了结。<br>之后专门写下树和图结构，判断链表是否有环的分析；</p>
<h3 id="the-end"><a href="#the-end" class="headerlink" title="the end"></a>the end</h3><p>基本的数据结构：</p>
<p>栈：后进先出(LIFO)，支出入栈和出栈等基本操作；<br>队列：先进先出(FIFO)，支持如队列和出队列等基本操作；<br>链表：元素间以指针或索引关联，头结点，节点元素；</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;复习基础的数据结构（栈，队列，链表）。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>buildout构建工具</title>
    <link href="https://yabzhang.github.io/2017/07/25/buildout%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    <id>https://yabzhang.github.io/2017/07/25/buildout构建工具/</id>
    <published>2017-07-25T00:40:10.000Z</published>
    <updated>2018-08-02T17:38:33.845Z</updated>
    
    <content type="html"><![CDATA[<p><code>buildout</code>构建工具的使用记录。<br><a id="more"></a></p>
<h3 id="prologue"><a href="#prologue" class="headerlink" title="prologue"></a>prologue</h3><blockquote><p>Buildout is a tool for automating software assembly.</p>
<ul>
<li>Run build tools to build software.</li>
<li>Apply software and templates to generate configuration files and scripts.</li>
<li>Application to all software phases, from development to production deployment.</li>
<li>Based on core priciples:<ol>
<li>Repeatability</li>
<li>Componentization</li>
<li>Automation</li>
</ol>
</li>
</ul>
<footer><strong>buildout doc,</strong><cite><a href="http://docs.buildout.org" target="_blank" rel="noopener">docs.buildout.org</a></cite></footer></blockquote>
<p>buildout的是一款自动化构建工具。<br>由<code>Zope</code>团队开发维护。包名为<code>zc.buildout</code>。</p>
<p><code>buildout</code>可以为应用构建独立的依赖环境。类似于<code>virtualenv</code>，但二者还有不同。<br>粗略地讲，<code>buildout</code>支持的功能更多更便于自动化而且具体定位有所不同。</p>
<h3 id="use-case"><a href="#use-case" class="headerlink" title="use case"></a>use case</h3><h4 id="install-buildout"><a href="#install-buildout" class="headerlink" title="install buildout"></a>install buildout</h4><ul>
<li>首先是安装buildout</li>
</ul>
<p><code>pip install zc.buildout</code></p>
<p>使用<code>pip</code>安装<code>zc.buildout</code>包。</p>
<ul>
<li>为项目配置buildout</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd project</span><br><span class="line">buildout init</span><br></pre></td></tr></table></figure>
<p><code>buildout init</code>在项目目录中初始化。初始化后，目录下会多出一些目录和文件。<br>其中<code>buildout.cfg</code>是默认的<code>buildout</code>配置文件。具体的配置留待下文介绍。</p>
<p><code>buildout init</code>会采用当前默认的python环境。也可以在隔离环境（如:<code>virtualenv</code>）中运行。<br>而且<code>buildout init</code>初始化并不会提供<code>bootstrap.py</code>文件。<br>这个文件由官方提供，为了便于自动化需要下载这个文件，并加到版本控制中。<a href="https://bootstrap.pypa.io/bootstrap-buildout.py" target="_blank" rel="noopener">传送门</a></p>
<p>基本的安装工作到这里就完成了。下面来看看如何使用<code>buildout</code>来构建一个环境。</p>
<ul>
<li>使用buildout构建应用环境</li>
</ul>
<p>假定我们需要在一台新的机器上构建<code>buildout</code>应用环境。<br>我们只需要进入项目目录，运行启动<code>bootstrap.py</code>脚本即可。<br><code>bootstrap.py</code>会自行完成<code>buildout</code>和依赖的安装，并按照<code>buildout.cfg</code>配置内容完成构建。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd project</span><br><span class="line">python bootstrap.py</span><br></pre></td></tr></table></figure>
<p>前文提到<code>buildout</code>可以在系统环境或隔离环境(如:<code>virtualenv</code>)构建具体的应用环境。<br>官方推荐在沙盒环境中构建:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">virtualenv -p python3 project</span><br><span class="line">cd project</span><br><span class="line">bin/python bootstrap.py</span><br></pre></td></tr></table></figure>
<p>目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">project/</span><br><span class="line">   bootstrap.py  †</span><br><span class="line">   buildout.cfg  †</span><br><span class="line">   .installed.cfg</span><br><span class="line">   parts/</span><br><span class="line">   develop-eggs/</span><br><span class="line">   bin/</span><br><span class="line">       buildout</span><br><span class="line">       mypython</span><br><span class="line">   eggs/</span><br><span class="line">   downloads/</span><br></pre></td></tr></table></figure>
<p>只有<code>bootstrap.py</code>和<code>buildout.cfg</code>需要加入到代码库。</p>
<h4 id="buildout-cfg配置"><a href="#buildout-cfg配置" class="headerlink" title="buildout.cfg配置"></a>buildout.cfg配置</h4><ul>
<li>简单的demo:</li>
</ul>
<script src="//gist.github.com/5adfe037c44555d4c2b4cebfe55eb2a9.js"></script>
<p><code>[buildout]</code>这个块是必需的，可以在此指定起用的配置块信息；<br><code>parts</code>中指定起用的块名字，数目任意，一行一个；<br><code>develop</code>用于指定创建<code>egg</code>包的目录，指定目录必须包含一个<code>setup.py</code>文件用于打包。</p>
<p><code>[event]</code>是自定义块；如<code>[event]</code>，<code>[server]</code>…<br><code>recipe</code>对自定义块是必需的，可以是分发好的包，也可以自行制作。<br>最常用的就是<code>zc.recipe.egg</code>，用于按照块定义打包(egg)。<br>包含了完成块定义逻辑代码，如安装依赖、生成脚本等。<br><code>eggs</code>指定了需要加载的egg包以及相关的依赖。<br><code>interpreter</code>会创建一个包含eggs和依赖的执行环境，在<code>bin</code>目录下。</p>
<p>更多选项参考文档。</p>
<ul>
<li>配置实例：</li>
</ul>
<script src="//gist.github.com/d172d3f67336ba1891dce2646cf5dfdd.js"></script>
<p><code>[buildout]</code>起用了<code>project</code>块，并在当前境目录打包。<br><code>[project]</code>用于创建一个’project’的包，并提供一个执行环境。<br><code>extra-paths</code>选项的值，为一个或多个路径，会被添加到环境解释器的搜索路径中。<br><code>{buildout:directory}</code>值为当前构建目录。<br><code>[versions]</code>部分指定依赖的版本要求。</p>
<p><code>develop</code>指定的打包目录中必须包含<code>setup.py</code>文件用于打包。<br><code>setup.py</code>文件包含了所有打包必须的信息，如版本，依赖，和入口等。<br><code>install_requires</code>中指定了依赖，如果缺失会使用<code>pip</code>安装。这里我采用了在<code>buildout.cfg</code>中进行包的版本管理。<br><code>entry_points</code>中指明了包的入口，<code>buildout</code>会创建一个此入口的启动脚本在<code>bin</code>目录下。</p>
<p><code>setup.py</code>的配置，又是另外一个话题了。更多选项参考文档。</p>
<ul>
<li><p>项目中的实例</p>
<p>  <a href="https://github.com/YabZhang/tornado_base" target="_blank" rel="noopener">传送门</a></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/YabZhang/tornado_base</span><br><span class="line">cd torando_base</span><br><span class="line"></span><br><span class="line"># install &amp;&amp; buildout</span><br><span class="line">python bootstrap.py</span><br><span class="line"></span><br><span class="line"># start server</span><br><span class="line">bin/server</span><br></pre></td></tr></table></figure>
<p>然后，就可以滚去写代码了…</p>
<h3 id="the-end"><a href="#the-end" class="headerlink" title="the end"></a>the end</h3><p><code>buildout</code>适用于自动化构建，能够有效提高工作效率。推荐与<code>virtualenv</code>一起使用。<br>功能上与<code>docker</code>和<code>make</code>有所重叠，好在简单快捷，也能很好地满足中小项目的需要，没做过大项目-.-;</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;buildout&lt;/code&gt;构建工具的使用记录。&lt;br&gt;
    
    </summary>
    
    
      <category term="buildout" scheme="https://yabzhang.github.io/tags/buildout/"/>
    
      <category term="automation" scheme="https://yabzhang.github.io/tags/automation/"/>
    
  </entry>
  
  <entry>
    <title>hexo标签体验</title>
    <link href="https://yabzhang.github.io/2017/07/23/hexo%E6%A0%87%E7%AD%BE%E4%BD%93%E9%AA%8C/"/>
    <id>https://yabzhang.github.io/2017/07/23/hexo标签体验/</id>
    <published>2017-07-22T17:34:12.000Z</published>
    <updated>2018-08-02T17:38:33.846Z</updated>
    
    <content type="html"><![CDATA[<p><code>hexo</code>模板标签使用之初体验。<br><a id="more"></a></p>
<h3 id="prologue"><a href="#prologue" class="headerlink" title="prologue"></a>prologue</h3><p> 今天搭好了hexo的博客，选了一个风格偏简化的主题。<br> 那么接下来就来测试下hexo的标签插件的具体效果。</p>
<h3 id="tag-test"><a href="#tag-test" class="headerlink" title="tag test"></a>tag test</h3><p> hexo的标签插件主要用于在文章中快速插入特定的内容。写法上有点像是jinja这样的模板语言。<br> 参考hexo文档，其标签插件包括引用、代码高亮和插入外链和图片的功能外，还支持文件代码引入，iframe, gist和youtube视频插入等。</p>
<h4 id="引用块"><a href="#引用块" class="headerlink" title="引用块"></a>引用块</h4><p> 在文章中插入引用块，可以包含作者、来源和标题。</p>
 <blockquote><p>引用块测试。</p>
<footer><strong>Yabin Zhang</strong><cite>Yabin Zhang's Blog</cite></footer></blockquote>
 <blockquote><p>再次引用块测试。</p>
<footer><strong>Yabin Zhang</strong></footer></blockquote>
 <blockquote><p>Try in English.</p>
<footer><strong>Yab Zhang</strong><cite><a href="https://yabzhang.github.io,">Test Plugin</a></cite></footer></blockquote>
<p> 引用块标识来源的展示有点问题。</p>
<h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p> 普通代码块<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(&apos;Hello, World&apos;);</span><br></pre></td></tr></table></figure></p>
<p> 指定语言<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]  <span class="comment"># Python</span></span><br></pre></td></tr></table></figure></p>
 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[rectangle setX: <span class="number">10</span> y: <span class="number">10</span> width: <span class="number">20</span> height: <span class="number">20</span>];  <span class="comment">// objc</span></span><br></pre></td></tr></table></figure>
<p> 附加说明<br> <figure class="highlight python"><figcaption><span>generator</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator</span><span class="params">(seq)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> range(seq):</span><br><span class="line">        <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure></p>
 <figure class="highlight js"><figcaption><span>Array.map</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight c"><figcaption><span>printf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello, World\n"</span>);</span><br></pre></td></tr></table></figure>
<p> 指明代码块的语言后可以语法高亮；<br> 不过附加说明的样式不是很满意。</p>
<h4 id="反引号代码块"><a href="#反引号代码块" class="headerlink" title="反引号代码块"></a>反引号代码块</h4> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">funciton print_log(item) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@decorator</span><br><span class="line">def logic_handler(a, *args, **kwargs):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<h4 id="Gist插入"><a href="#Gist插入" class="headerlink" title="Gist插入"></a>Gist插入</h4> <script src="//gist.github.com/d172d3f67336ba1891dce2646cf5dfdd.js"></script>
<p> gist插入的特性挺棒的，但是在gist中包含多个文件时，指定文件名展示失败；</p>
<h4 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h4><p> 资源文件引用：<br> <img src="/2017/07/23/hexo标签体验/ayanami.jpg" title="local file"></p>
<p> 外链图片, 可指定大小:<br> <img src="http://icons.iconarchive.com/icons/artcore-illustrations/artcore-4/512/github-icon.png" width="200" height="200"></p>
<h4 id="外链"><a href="#外链" class="headerlink" title="外链"></a>外链</h4> <a href="https://hexo.io/zh-cn/doc" target="_blank" rel="noopener">Hexo So Cool</a>
<h4 id="插入代码文件"><a href="#插入代码文件" class="headerlink" title="插入代码文件"></a>插入代码文件</h4>  
<p> 代码文件展示失败，又或者我姿势不对。</p>
<h4 id="插入youtube视频"><a href="#插入youtube视频" class="headerlink" title="插入youtube视频"></a>插入youtube视频</h4><p>  昨天看到Linkin Park主唱自杀的消息，感到特别惋惜。<br>  在我最黑暗的时候，那壮怀激烈的歌声不止一次地给我希望。<br>  给世界都来了那么多光明，却没一缕光能留得住你。<br>  一路好走。</p>
  <div class="video-container"><iframe src="//www.youtube.com/embed/kXYiU_JCYtU" frameborder="0" allowfullscreen></iframe></div>
<h3 id="end"><a href="#end" class="headerlink" title="end"></a>end</h3><p>  以上就是对新博客的测试。<br>  有些地方还有瑕疵，但整体上还比较满意。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;hexo&lt;/code&gt;模板标签使用之初体验。&lt;br&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://yabzhang.github.io/tags/hexo/"/>
    
      <category term="tags" scheme="https://yabzhang.github.io/tags/tags/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://yabzhang.github.io/2017/07/23/hello-world/"/>
    <id>https://yabzhang.github.io/2017/07/23/hello-world/</id>
    <published>2017-07-22T16:00:00.000Z</published>
    <updated>2018-08-02T17:38:33.846Z</updated>
    
    <content type="html"><![CDATA[<p>Hello, World<br><a id="more"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hello, World&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
